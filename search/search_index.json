{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Imba guide \u00b6 This is a quick guide for Imba v1.4, which focuses on the language itself. Imba is not just a programming language. It's a programming language optimized for the web. One of Imba's most notable features is the built-in web application framework with a fast DOM reconciler called the Memoized DOM. This allows Imba developers to easily create performant web applications in a fun and natural way. The performance of the Memoized DOM is so good, in fact, that Imba is... well, imba . If you are not into gaming, it means that Imba opens the doors to architectural patterns that are not practical in many of the today's popular frameworks and libraries. This guide is designed to get you up to speed having fun with Imba. You may not want to hear this, though, but \"quick\" is just a click-bait. The guide really quite substantial. Just as there is no way to get 8 hours of sleep in 30 minutes, there is no way to compress important information about a programming language into a few paragraphs. As with any game, though, we have provided cheats for those of you who don't want to read too much. Don't worry, we don't hate on cheaters. Who this guide is for \u00b6 This guide is written primarily for those who have nothing better to do in life than learn one of the best languages for web development to date. But hey, what could be better anyway! Ehm... let's get serious. This quick guide is aimed at programmers coming from different languages , not just JavaScript programmers. Many concepts are explained in detail even when they are identical or very similar in JavaScript. Having said that, Imba does not live separately from JavaScript. Imba takes advantage of the JavaScript engine it runs in by providing unrestricted access to the built-in JavaScript APIs. This guide will not attempt to translate all those APIs to Imba. Instead, it will provide links to relevant JavaScript documentation. If you are coming from JavaScript , you may still want to read through this guide as a refresher for some of the concepts. Or you may simply skip from one code snippet to another, and only read the surrounding text if the code looks unfamiliar. We have prepared a list of Cheats in each section that will cover the differences and similarities between Imba and JavaScript. How to use this guide \u00b6 The first recommendation is to read it. Also, like, share, and sub. :-) We also recommend you get as hands-on as possible while reading through this guide. If you wish to follow along, we recommend you hop on Scrimba.com , an online sandbox/screencast service written in Imba. You can also use the playground found in this guide's git repository. Instructions for getting started with the playground are in the README.md file. Note In Scrimba, pressing Cmd+J or Ctrl+J when some Imba code is selected will give you a compiled version of the code. We will cover setting up Imba projects from scratch in one of the bonus sections .","title":"Imba guide"},{"location":"#imba-guide","text":"This is a quick guide for Imba v1.4, which focuses on the language itself. Imba is not just a programming language. It's a programming language optimized for the web. One of Imba's most notable features is the built-in web application framework with a fast DOM reconciler called the Memoized DOM. This allows Imba developers to easily create performant web applications in a fun and natural way. The performance of the Memoized DOM is so good, in fact, that Imba is... well, imba . If you are not into gaming, it means that Imba opens the doors to architectural patterns that are not practical in many of the today's popular frameworks and libraries. This guide is designed to get you up to speed having fun with Imba. You may not want to hear this, though, but \"quick\" is just a click-bait. The guide really quite substantial. Just as there is no way to get 8 hours of sleep in 30 minutes, there is no way to compress important information about a programming language into a few paragraphs. As with any game, though, we have provided cheats for those of you who don't want to read too much. Don't worry, we don't hate on cheaters.","title":"Imba guide"},{"location":"#who-this-guide-is-for","text":"This guide is written primarily for those who have nothing better to do in life than learn one of the best languages for web development to date. But hey, what could be better anyway! Ehm... let's get serious. This quick guide is aimed at programmers coming from different languages , not just JavaScript programmers. Many concepts are explained in detail even when they are identical or very similar in JavaScript. Having said that, Imba does not live separately from JavaScript. Imba takes advantage of the JavaScript engine it runs in by providing unrestricted access to the built-in JavaScript APIs. This guide will not attempt to translate all those APIs to Imba. Instead, it will provide links to relevant JavaScript documentation. If you are coming from JavaScript , you may still want to read through this guide as a refresher for some of the concepts. Or you may simply skip from one code snippet to another, and only read the surrounding text if the code looks unfamiliar. We have prepared a list of Cheats in each section that will cover the differences and similarities between Imba and JavaScript.","title":"Who this guide is for"},{"location":"#how-to-use-this-guide","text":"The first recommendation is to read it. Also, like, share, and sub. :-) We also recommend you get as hands-on as possible while reading through this guide. If you wish to follow along, we recommend you hop on Scrimba.com , an online sandbox/screencast service written in Imba. You can also use the playground found in this guide's git repository. Instructions for getting started with the playground are in the README.md file. Note In Scrimba, pressing Cmd+J or Ctrl+J when some Imba code is selected will give you a compiled version of the code. We will cover setting up Imba projects from scratch in one of the bonus sections .","title":"How to use this guide"},{"location":"bonus/escapes/","text":"Escape sequences \u00b6 Escape sequence is a sequence of backslash \\ followed by one or more characters. They are used to represent some of the special characters in a strings and regular expressions. Common escape sequences \u00b6 \\' - single quote \\\" - double quote \\\\ - backslash \\b - backspace \\f - form feed \\n - line feed \\r - carriage return \\t - horizontal tab \\v - vertical tab \\0 - NULL character Hexadecimal escape sequences \u00b6 Some characters can be escaped using hexadecimal notation. These are the characters in the ASCII range (0-255). The hexadecimal escape sequences are in the \\xnn format where nn is a two-digit hexadecimal number. Unicode escape sequences \u00b6 There are two formats of the Unicode escape sequences. \\unnnn - UTF-16 with four hexadecimal digits nnnn \\u{nnnn} ~ \\u{nnnnn} - Unicode with four or five hexadecimal digits nnnn A full table of Unicode characters can be found on unicode-table.com .","title":"Escape sequences"},{"location":"bonus/escapes/#escape-sequences","text":"Escape sequence is a sequence of backslash \\ followed by one or more characters. They are used to represent some of the special characters in a strings and regular expressions.","title":"Escape sequences"},{"location":"bonus/escapes/#common-escape-sequences","text":"\\' - single quote \\\" - double quote \\\\ - backslash \\b - backspace \\f - form feed \\n - line feed \\r - carriage return \\t - horizontal tab \\v - vertical tab \\0 - NULL character","title":"Common escape sequences"},{"location":"bonus/escapes/#hexadecimal-escape-sequences","text":"Some characters can be escaped using hexadecimal notation. These are the characters in the ASCII range (0-255). The hexadecimal escape sequences are in the \\xnn format where nn is a two-digit hexadecimal number.","title":"Hexadecimal escape sequences"},{"location":"bonus/escapes/#unicode-escape-sequences","text":"There are two formats of the Unicode escape sequences. \\unnnn - UTF-16 with four hexadecimal digits nnnn \\u{nnnn} ~ \\u{nnnnn} - Unicode with four or five hexadecimal digits nnnn A full table of Unicode characters can be found on unicode-table.com .","title":"Unicode escape sequences"},{"location":"bonus/memoized/","text":"Memoized DOM \u00b6","title":"Memoized DOM"},{"location":"bonus/memoized/#memoized-dom","text":"","title":"Memoized DOM"},{"location":"bonus/migration/","text":"","title":"Migration"},{"location":"bonus/setup/","text":"","title":"Setup"},{"location":"bonus/testing/","text":"","title":"Testing"},{"location":"bonus/typedet/","text":"Alternative type detection \u00b6 Because of quirks in in JavaScript type system, some programmers resort to using ({}):toString.call . Here is an example: 1 2 3 4 5 6 7 8 9 def realType x ({}):toString.call(x) # this line would return '[object Somethng]' .split(' ')[1] # take the second half .slice 0, -1 # remove the trailing ']' realType 'string' # 'String' realType 1 # 'Number' realType null # 'Null' realType Date.new # 'Date' While this technique is not generally used, it can become useful when building frameworks and libraries. Note The realType function in the example is able to detect both the types and constructor names of (some) objects.","title":"Alternative type detection"},{"location":"bonus/typedet/#alternative-type-detection","text":"Because of quirks in in JavaScript type system, some programmers resort to using ({}):toString.call . Here is an example: 1 2 3 4 5 6 7 8 9 def realType x ({}):toString.call(x) # this line would return '[object Somethng]' .split(' ')[1] # take the second half .slice 0, -1 # remove the trailing ']' realType 'string' # 'String' realType 1 # 'Number' realType null # 'Null' realType Date.new # 'Date' While this technique is not generally used, it can become useful when building frameworks and libraries. Note The realType function in the example is able to detect both the types and constructor names of (some) objects.","title":"Alternative type detection"},{"location":"lvl0/about/","text":"About Imba \u00b6 Imba is a dynamically typed multi-paradigm object-based language which transpiles to performant JavaScript. Its design is well suited for both fun and profit. Features \u00b6 Imba is primarily developed for web development, although it can be used to write general purpose NodeJS programs. This is enabled by the following two features: First-class tags - declarative syntax for creating and updating DOM nodes similar to web components. Memoized DOM - a built-in high-performance DOM reconciler. The language itself also offers interesting features that makes programming a lot more fun: Fully interoperable with JavaScript - which allows progressive migration and gives us the ability to leverage existing tools. Block expressions - if , try , while , until and for loops are expressions that can be assigned and passed as arguments. Implicit return - last expression in a method is its return value. Significant whitespace - using whitespace to delimit blocks reduces the amount of punctuation and improves readability. Multi-line strings and regexps - improves code readability by not requiring programmers to do crazy things just to do something as obvious as this. Short history of the project \u00b6 Imba was created around 2010 by Sindre Aarsaether ( @somebee ) as a private project to port Ruby to browsers. As time progressed, the project morphed into an effort to create an optimal platform for end-to-end end web development. Even though the speed was not one of the original goals, the implementation of the Imba's DOM reconciler, also known as 'Memoized DOM' , has stood the test of time, and is, to date, one of the fastest DOM reconciler designs on the market. Many of today's high-performance designs use the same or similar techniques. About the name \u00b6 The name Imba comes from the term 'imba' commonly used in the gaming world to point to a character or an item that is overpowered and therefore causes the gameplay to become imbalanced. Relationship between Imba and JavaScript \u00b6 Imba does not exist in isolation from the JavaScript ecosystem. It not only compiles to JavaScript, but can also import JavaScript modules and use any global objects defined in the JavaScript runtime environment (e.g., window or global , console.log , and so on). You can read more about the differences in by reading the Cheats heading in each section.","title":"About Imba"},{"location":"lvl0/about/#about-imba","text":"Imba is a dynamically typed multi-paradigm object-based language which transpiles to performant JavaScript. Its design is well suited for both fun and profit.","title":"About Imba"},{"location":"lvl0/about/#features","text":"Imba is primarily developed for web development, although it can be used to write general purpose NodeJS programs. This is enabled by the following two features: First-class tags - declarative syntax for creating and updating DOM nodes similar to web components. Memoized DOM - a built-in high-performance DOM reconciler. The language itself also offers interesting features that makes programming a lot more fun: Fully interoperable with JavaScript - which allows progressive migration and gives us the ability to leverage existing tools. Block expressions - if , try , while , until and for loops are expressions that can be assigned and passed as arguments. Implicit return - last expression in a method is its return value. Significant whitespace - using whitespace to delimit blocks reduces the amount of punctuation and improves readability. Multi-line strings and regexps - improves code readability by not requiring programmers to do crazy things just to do something as obvious as this.","title":"Features"},{"location":"lvl0/about/#short-history-of-the-project","text":"Imba was created around 2010 by Sindre Aarsaether ( @somebee ) as a private project to port Ruby to browsers. As time progressed, the project morphed into an effort to create an optimal platform for end-to-end end web development. Even though the speed was not one of the original goals, the implementation of the Imba's DOM reconciler, also known as 'Memoized DOM' , has stood the test of time, and is, to date, one of the fastest DOM reconciler designs on the market. Many of today's high-performance designs use the same or similar techniques.","title":"Short history of the project"},{"location":"lvl0/about/#about-the-name","text":"The name Imba comes from the term 'imba' commonly used in the gaming world to point to a character or an item that is overpowered and therefore causes the gameplay to become imbalanced.","title":"About the name"},{"location":"lvl0/about/#relationship-between-imba-and-javascript","text":"Imba does not exist in isolation from the JavaScript ecosystem. It not only compiles to JavaScript, but can also import JavaScript modules and use any global objects defined in the JavaScript runtime environment (e.g., window or global , console.log , and so on). You can read more about the differences in by reading the Cheats heading in each section.","title":"Relationship between Imba and JavaScript"},{"location":"lvl0/editors/","text":"Setting up your editor \u00b6 SublimeText 3 \u00b6 There is an Imba plugin for SublimeText 3 . You can install it using package control. VisualStudio Code \u00b6 A plugin vscode-imba can be obtained and installed from the editor's extension manager. Atom \u00b6 The Atom plugin repository contains a language-imba package.","title":"Setting up your editor"},{"location":"lvl0/editors/#setting-up-your-editor","text":"","title":"Setting up your editor"},{"location":"lvl0/editors/#sublimetext-3","text":"There is an Imba plugin for SublimeText 3 . You can install it using package control.","title":"SublimeText 3"},{"location":"lvl0/editors/#visualstudio-code","text":"A plugin vscode-imba can be obtained and installed from the editor's extension manager.","title":"VisualStudio Code"},{"location":"lvl0/editors/#atom","text":"The Atom plugin repository contains a language-imba package.","title":"Atom"},{"location":"lvl0/sample/","text":"\"Hello, World\" example \u00b6 Here is a small \"Hello, World\" application as a quick glance at Imba. The code \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 var state = { name: 'World' } tag App def render <self> <p> \"Hello, {data:name}\" <p> <input[data:name]> Imba.mount <App[state]> You can see the code in a live sandbox at Scrimba . Breakdown \u00b6 The state variable is an object that contains the application state. In our case, it only has one property, name , which starts off as a string 'World' . A custom tag , App , contains the render method that renders the application. The special <self> tag stands for the DOM element for the custom tag itself, and tags below it represent the child elements. The string \"Hello, {data:name}\" uses interpolation to insert the value of data:name . data is a special property on tags that points to values bound to the tags. The <input[data:name]> creates an input element with data:name bound to it. This is two-way data binding where changes to the input element will update the data:name and vice-versa. Finally, with Imba.mount we mount the application into document.body , and bind the state object to the App tag.","title":"\"Hello, World\" example"},{"location":"lvl0/sample/#hello-world-example","text":"Here is a small \"Hello, World\" application as a quick glance at Imba.","title":"\"Hello, World\" example"},{"location":"lvl0/sample/#the-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 var state = { name: 'World' } tag App def render <self> <p> \"Hello, {data:name}\" <p> <input[data:name]> Imba.mount <App[state]> You can see the code in a live sandbox at Scrimba .","title":"The code"},{"location":"lvl0/sample/#breakdown","text":"The state variable is an object that contains the application state. In our case, it only has one property, name , which starts off as a string 'World' . A custom tag , App , contains the render method that renders the application. The special <self> tag stands for the DOM element for the custom tag itself, and tags below it represent the child elements. The string \"Hello, {data:name}\" uses interpolation to insert the value of data:name . data is a special property on tags that points to values bound to the tags. The <input[data:name]> creates an input element with data:name bound to it. This is two-way data binding where changes to the input element will update the data:name and vice-versa. Finally, with Imba.mount we mount the application into document.body , and bind the state object to the App tag.","title":"Breakdown"},{"location":"lvl0/structure/","text":"Guide structure and conventions \u00b6 The guide is divided into three parts. Level 1 covers the language basics. It gives you a fairly complete coverage of all the basics that would be required to write very simple programs. Level 2 covers the more complex concepts such as modules and classes. It will give you a good foundation for the syntax and mechanics of these concepts without going too deep into how you can use them (there are better books on the topic). Bonus material will cover miscellaneous topics that are outside of the scope of a language guide. These topics include such things as building and testing Imba programs. Cheats \u00b6 Each section has a Cheats heading which gives an express overview for experienced programmers. Conventions \u00b6 Strict \u00b6 Imba, by default, does not compile with use strict . The code examples in this guide will assume use strict . If you don't know what this means, always be sure to have \"use strict\" as the first line in your Imba files. You can read more about the strict mode on MDN . The global object \u00b6 In code snippets, we will use window as the global object. Keep in mind that on NodeJS, this object is called global . Compiler output \u00b6 In the code examples, we will sometimes reference the compiled JavaScript code. The result of the compilation will usually be presented in the same line or the line below, and will be in the #>> code... format for brevity. When the space does not permit, compiled code will be presented as a separate code block that includes the comment /*** compiler output ***/ at the top. JavaScript programmer warnings \u00b6 In some sections, we include a warning box to warn JavaScript developers of significant differences between Imba and JavaScript. Like this: Warning JavaScript developers, beware of this difference!","title":"Guide structure and conventions"},{"location":"lvl0/structure/#guide-structure-and-conventions","text":"The guide is divided into three parts. Level 1 covers the language basics. It gives you a fairly complete coverage of all the basics that would be required to write very simple programs. Level 2 covers the more complex concepts such as modules and classes. It will give you a good foundation for the syntax and mechanics of these concepts without going too deep into how you can use them (there are better books on the topic). Bonus material will cover miscellaneous topics that are outside of the scope of a language guide. These topics include such things as building and testing Imba programs.","title":"Guide structure and conventions"},{"location":"lvl0/structure/#cheats","text":"Each section has a Cheats heading which gives an express overview for experienced programmers.","title":"Cheats"},{"location":"lvl0/structure/#conventions","text":"","title":"Conventions"},{"location":"lvl0/structure/#strict","text":"Imba, by default, does not compile with use strict . The code examples in this guide will assume use strict . If you don't know what this means, always be sure to have \"use strict\" as the first line in your Imba files. You can read more about the strict mode on MDN .","title":"Strict"},{"location":"lvl0/structure/#the-global-object","text":"In code snippets, we will use window as the global object. Keep in mind that on NodeJS, this object is called global .","title":"The global object"},{"location":"lvl0/structure/#compiler-output","text":"In the code examples, we will sometimes reference the compiled JavaScript code. The result of the compilation will usually be presented in the same line or the line below, and will be in the #>> code... format for brevity. When the space does not permit, compiled code will be presented as a separate code block that includes the comment /*** compiler output ***/ at the top.","title":"Compiler output"},{"location":"lvl0/structure/#javascript-programmer-warnings","text":"In some sections, we include a warning box to warn JavaScript developers of significant differences between Imba and JavaScript. Like this: Warning JavaScript developers, beware of this difference!","title":"JavaScript programmer warnings"},{"location":"lvl0/tips/","text":"Tips and tricks for beginners \u00b6 If you are new to compile-to-JavaScript languages, here's a few tips that can help you get up to speed. Know JavaScript \u00b6 Do try to learn JavaScript as well as Imba. Even after learning Imba, you will still need to be at least aware of the various Web APIs that browsers offer. Even though Imba is a separate language, it runs in the browser after it's compiled to JavaScript, so you can and should take advantage of all the APIs browsers offer. Here is a short list of resources that can get you started: MDN NPM Webpack Use the developer tools in your browser \u00b6 Learn how to use developer tools in your browser. Especially the console. An easy start would be to add console.log calls in your code to inspect variable names. Chrome DevTools Firefox developer tools Safari web inspector Edge devtools Read the code Imba generates \u00b6 If you already know JavaScript, it's very helpful to inspect the code emitted by the Imba compiler. Especially in the beginning and when you run into issues. This is sometimes way faster than debugging.","title":"Tips and tricks for beginners"},{"location":"lvl0/tips/#tips-and-tricks-for-beginners","text":"If you are new to compile-to-JavaScript languages, here's a few tips that can help you get up to speed.","title":"Tips and tricks for beginners"},{"location":"lvl0/tips/#know-javascript","text":"Do try to learn JavaScript as well as Imba. Even after learning Imba, you will still need to be at least aware of the various Web APIs that browsers offer. Even though Imba is a separate language, it runs in the browser after it's compiled to JavaScript, so you can and should take advantage of all the APIs browsers offer. Here is a short list of resources that can get you started: MDN NPM Webpack","title":"Know JavaScript"},{"location":"lvl0/tips/#use-the-developer-tools-in-your-browser","text":"Learn how to use developer tools in your browser. Especially the console. An easy start would be to add console.log calls in your code to inspect variable names. Chrome DevTools Firefox developer tools Safari web inspector Edge devtools","title":"Use the developer tools in your browser"},{"location":"lvl0/tips/#read-the-code-imba-generates","text":"If you already know JavaScript, it's very helpful to inspect the code emitted by the Imba compiler. Especially in the beginning and when you run into issues. This is sometimes way faster than debugging.","title":"Read the code Imba generates"},{"location":"lvl1/","text":"Language basics \u00b6 This level presents the fundamental building blocks in Imba. These are the things that every Imba program must have. After completing this level, you will be able to write basic Imba programs.","title":"Language basics"},{"location":"lvl1/#language-basics","text":"This level presents the fundamental building blocks in Imba. These are the things that every Imba program must have. After completing this level, you will be able to write basic Imba programs.","title":"Language basics"},{"location":"lvl1/arrays/","text":"Arrays \u00b6 Arrays are objects containing an ordered and indexed list of values. Just like objects , arrays can be modified after creation, by adding or removing values. Cheats \u00b6 Arrays work in Imba the same way as in JavaScript. Commas , are optional when listing values vertically. Arrays can be looped over with for val in arr and for val, idx in arr . Creating arrays \u00b6 Arrays can be created either using the literal syntax, or by evaluating for , while , or until loops (more on those in Control structure ). Array literals are written using a pair of square brackets [ ] containing a list of comma-separated values. 1 var moves = [3, 2, 4] When values are listed vertically, commas are optional. 1 2 3 4 5 var achievements = [ 'level up', 'collect 100 gold', 'triple combo', ] Arrays can also be values in other arrays. 1 2 3 4 5 var L = [ [0, 1, 0] [0, 1, 0] [0, 1, 1] ] Empty arrays are written as just a pair of brackets. 1 var yourProblems = [] Accessing array elements \u00b6 Array elements are accessed using computed member access operator [ ] . Indices of array members start at 0, so the first element in the array has an index 0, the next one is 1, then 2, and so on. The last index in an array is always one less than the array's length. 1 2 3 var scores = [100, 200, 400, 500] scores[0] # 100 scores[2] # 400 Array length is obtained through the :length property. 1 2 scores:length #4 var lastItem = scores[scores:length - 1] As can be seen from the last example, we can use arbitrary expression inside the square brackets, so long as they evaluate to a number. Accessing an array index that is larger than its maximum index will evaluate to undefined and will not result in an error. 1 scores[40] # undefined Iterating over array members \u00b6 Array members can be iterated (looped) over using the for in block. We can either iterate over the values only, or both values and indices. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 var colors = ['black', 'blue', 'red', 'green', 'white'] for color in colors console.log color # 'black' # 'blue' # 'red' # 'green' # 'white' for color, i in colors console.log i, color # 0 'black' # 1 'blue' # 2 'red' # 3 'green' # 4 'white' var colorIndex = {} for color, i in colors colorIndex[color] = i colorIndex:red # 2 You can read more about the for in block in the Control structures section. Manipulating arrays \u00b6 Arrays can be manipulated by assigning values to array indices, adding or removing members from them, or reversing them. Values at an existing index can be changed by simply assigning to that member. 1 2 3 4 5 var classes = ['rogue', 'wizard', 'knight', 'paladin'] classes[0] = 'thief' classes[0] # 'thief' Non-existent indices should not be used when assigning. While it may seem to work, it will result in strange behavior. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 classes[6] = 'programmer' classes:length # 7 for cls in classes console.log cls # 'thief' # 'wizard' # 'knight' # 'paladin', # undefined # undefined # 'programmer' classes # ['thief', 'wizard', 'knight', 'paladin', <2 empty slots>, 'programmer'] For simply iterating over the array using for in , it would seem as if nothing is wrong, but the two undefined members that were logged are actually not real members. They are called 'empty slots', and affect the behavior of different array methods we will discuss later. The only exception to the above recommendation is the index following the last one. The index after the last one is also the value of the :length property. 1 2 3 4 5 6 7 8 9 10 var classes = ['rogue', 'wizard', 'knight', 'paladin'] classes[classes:length] = 'programmer' for cls in classes console.log cls # 'rogue' # 'wizard' # 'knight' # 'paladin', # 'programmer' Useful methods and properties \u00b6 :length .concat .every .fill .filter .find .findIndex .forEach .includes .indexOf .join .map .pop .push .reduce .reduceRight .reverse .shift .slice .some .sort .splice .unshift","title":"Arrays"},{"location":"lvl1/arrays/#arrays","text":"Arrays are objects containing an ordered and indexed list of values. Just like objects , arrays can be modified after creation, by adding or removing values.","title":"Arrays"},{"location":"lvl1/arrays/#cheats","text":"Arrays work in Imba the same way as in JavaScript. Commas , are optional when listing values vertically. Arrays can be looped over with for val in arr and for val, idx in arr .","title":"Cheats"},{"location":"lvl1/arrays/#creating-arrays","text":"Arrays can be created either using the literal syntax, or by evaluating for , while , or until loops (more on those in Control structure ). Array literals are written using a pair of square brackets [ ] containing a list of comma-separated values. 1 var moves = [3, 2, 4] When values are listed vertically, commas are optional. 1 2 3 4 5 var achievements = [ 'level up', 'collect 100 gold', 'triple combo', ] Arrays can also be values in other arrays. 1 2 3 4 5 var L = [ [0, 1, 0] [0, 1, 0] [0, 1, 1] ] Empty arrays are written as just a pair of brackets. 1 var yourProblems = []","title":"Creating arrays"},{"location":"lvl1/arrays/#accessing-array-elements","text":"Array elements are accessed using computed member access operator [ ] . Indices of array members start at 0, so the first element in the array has an index 0, the next one is 1, then 2, and so on. The last index in an array is always one less than the array's length. 1 2 3 var scores = [100, 200, 400, 500] scores[0] # 100 scores[2] # 400 Array length is obtained through the :length property. 1 2 scores:length #4 var lastItem = scores[scores:length - 1] As can be seen from the last example, we can use arbitrary expression inside the square brackets, so long as they evaluate to a number. Accessing an array index that is larger than its maximum index will evaluate to undefined and will not result in an error. 1 scores[40] # undefined","title":"Accessing array elements"},{"location":"lvl1/arrays/#iterating-over-array-members","text":"Array members can be iterated (looped) over using the for in block. We can either iterate over the values only, or both values and indices. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 var colors = ['black', 'blue', 'red', 'green', 'white'] for color in colors console.log color # 'black' # 'blue' # 'red' # 'green' # 'white' for color, i in colors console.log i, color # 0 'black' # 1 'blue' # 2 'red' # 3 'green' # 4 'white' var colorIndex = {} for color, i in colors colorIndex[color] = i colorIndex:red # 2 You can read more about the for in block in the Control structures section.","title":"Iterating over array members"},{"location":"lvl1/arrays/#manipulating-arrays","text":"Arrays can be manipulated by assigning values to array indices, adding or removing members from them, or reversing them. Values at an existing index can be changed by simply assigning to that member. 1 2 3 4 5 var classes = ['rogue', 'wizard', 'knight', 'paladin'] classes[0] = 'thief' classes[0] # 'thief' Non-existent indices should not be used when assigning. While it may seem to work, it will result in strange behavior. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 classes[6] = 'programmer' classes:length # 7 for cls in classes console.log cls # 'thief' # 'wizard' # 'knight' # 'paladin', # undefined # undefined # 'programmer' classes # ['thief', 'wizard', 'knight', 'paladin', <2 empty slots>, 'programmer'] For simply iterating over the array using for in , it would seem as if nothing is wrong, but the two undefined members that were logged are actually not real members. They are called 'empty slots', and affect the behavior of different array methods we will discuss later. The only exception to the above recommendation is the index following the last one. The index after the last one is also the value of the :length property. 1 2 3 4 5 6 7 8 9 10 var classes = ['rogue', 'wizard', 'knight', 'paladin'] classes[classes:length] = 'programmer' for cls in classes console.log cls # 'rogue' # 'wizard' # 'knight' # 'paladin', # 'programmer'","title":"Manipulating arrays"},{"location":"lvl1/arrays/#useful-methods-and-properties","text":":length .concat .every .fill .filter .find .findIndex .forEach .includes .indexOf .join .map .pop .push .reduce .reduceRight .reverse .shift .slice .some .sort .splice .unshift","title":"Useful methods and properties"},{"location":"lvl1/comments/","text":"Comments \u00b6 Comments are used to add annotation to your code or prevent pieces of code from running. The contents of the comments are completely ignored by the compiler. Imba has inline and block comments. Cheats \u00b6 Inline comments start with # Block comments are delimited by ### Inline comments \u00b6 The character that signifies a comment is the hash character # . Inline comments begin at the first # on the line, and are terminated by a newline. 1 2 # This is a inline (single-line) comment. 'Imba' # Inline comment can be used at the end of the code. Block comments \u00b6 Block comments are delimited by triple-hash ### which are on their own lines. The initial triple-hash must be at the very beginning of the line but can be followed by any characters. 1 2 3 4 5 6 7 8 9 ### This is a block comment. It can span multiple lines. ### ###This is also a block comment.### ### And so is this. ### Note When using block comments, at least one non-hash character must be present after the opening triple-hash. Using comments \u00b6 Inline comments are usually used for short comments about the next or current line. This is sometimes used to bring attention to a particular line or a few lines or explain the less obvious. 1 var menuHeight = window::innerHeight * 0.8 - 42 # 42px from the top Blocks comments are used for longer comments that describe the behavior of methods and classes that come immediately after them, or even whole modules. 1 2 3 4 5 6 7 ### Add two values together. Also works on strings. When `x` is a string, `y` can be of any type. ### def add x, y x + y","title":"Comments"},{"location":"lvl1/comments/#comments","text":"Comments are used to add annotation to your code or prevent pieces of code from running. The contents of the comments are completely ignored by the compiler. Imba has inline and block comments.","title":"Comments"},{"location":"lvl1/comments/#cheats","text":"Inline comments start with # Block comments are delimited by ###","title":"Cheats"},{"location":"lvl1/comments/#inline-comments","text":"The character that signifies a comment is the hash character # . Inline comments begin at the first # on the line, and are terminated by a newline. 1 2 # This is a inline (single-line) comment. 'Imba' # Inline comment can be used at the end of the code.","title":"Inline comments"},{"location":"lvl1/comments/#block-comments","text":"Block comments are delimited by triple-hash ### which are on their own lines. The initial triple-hash must be at the very beginning of the line but can be followed by any characters. 1 2 3 4 5 6 7 8 9 ### This is a block comment. It can span multiple lines. ### ###This is also a block comment.### ### And so is this. ### Note When using block comments, at least one non-hash character must be present after the opening triple-hash.","title":"Block comments"},{"location":"lvl1/comments/#using-comments","text":"Inline comments are usually used for short comments about the next or current line. This is sometimes used to bring attention to a particular line or a few lines or explain the less obvious. 1 var menuHeight = window::innerHeight * 0.8 - 42 # 42px from the top Blocks comments are used for longer comments that describe the behavior of methods and classes that come immediately after them, or even whole modules. 1 2 3 4 5 6 7 ### Add two values together. Also works on strings. When `x` is a string, `y` can be of any type. ### def add x, y x + y","title":"Using comments"},{"location":"lvl1/controls/","text":"Control structures - if, try, for, while, until \u00b6 Control structures control the flow of execution by providing mechanism for branching and repeating execution of code. Imba has several different control structures. if blocks control branching try blocks handle exceptions loops ( for , while , until ) allow repetitive execution of code blocks Cheats \u00b6 Imba has the if , try , while , until and for blocks. All blocks are expressions which can be assigned and passed around. There are no parentheses around conditions. There is no punctuation in blocks (e.g., if x ). if block can have else if and else branches. for , white , until can be passed and assigned as arrays. for , white , until can break and continue . for x in arr or for x, idx in arr to loop over arrays. for key of obj or for key, val of obj to loop over object properties. There is no for i; i < j; i++ version of for loop in Imba. catch is optional in try block. The if block \u00b6 Sometimes we want to do different things depending on some condition. For instance, 'if user is logged in, show them the profile page, and otherwise take them to the log in page.' Just like the name suggests, the if blocks are only evaluated if some condition is met. The condition can be any valid Imba expression, including any of the control blocks found in this section (yes, if block itself, too!). For example: 1 2 3 4 var lives = 0 if lives is 0 'You are dead' We can also specify what happens in the other case: 1 2 3 4 5 6 7 var lives = 3 if lives is 0 'You are dead' else lives -= 1 \"You have {lives} more lives\" The if block is not restricted to just if and else branches. One or more additional conditions can be specified as else if branches. For example: 1 2 3 4 5 6 7 8 9 10 var lives = 3 if lives is 0 'You are dead' else if lives is 1 lives -= 1 'You are mine next time!' else lives -= 1 \"You have {lives} more lives\". If blocks can be assigned to variables. 1 2 3 4 5 6 7 8 9 10 var lives = 3 var x = if lives is 0 'You are dead' else lives -= 1 \"You have {lives} more lives\" x # \"You have 2 more lives\" Ternary expression \u00b6 In some cases, we can write the if block as a ternary expression to save space. Ternary expression is not technically a control structure, but we will mention it here because we don't have a better things to do anyway. 1 2 var lives = 3 var isDead = if lives is 0 then yes else no The else if branches cannot be used in ternary expressions. The try block \u00b6 Perfectly valid code will sometimes throw exceptions. Exceptions are objects generated by some error condition or thrown by some code. Exception objects will propagate through the application from the point where it was thrown, then back up through the path that lead to the point. If it is not caught somewhere on the path, it will eventually reach the JavaScript engine itself, and be treated as an 'uncaught' exception. (This is usually going to show up as a traceback in the developer console or in the terminal.) 1 2 3 4 5 6 7 def foogGun throw Error 'bug!' try footGun catch e console.log \"That was close! Let's do it again!\" The e variable in the catch branch is the error object that was thrown by the footGun method. Note that the catch branch is optional . If we simply wish to suppress an exception without doing anything, we can completely omit it. 1 2 3 try fooGun # Look, mom, no catch! Like if blocks, the try block can be assigned 1 2 3 4 var afermath = try footGun catch e 'Feeling exceptionally good!' The while loop \u00b6 The while loop is the simplest control structure for repeating blocks of code. It repeats the block while some condition is met, hence the name. 1 2 3 4 var bullets = 1000 white bullets > 0 bullets-- Other than letting the while loop run until the condition no longer applies, we can also end it prematurely by using the break or return statements. 1 2 3 4 5 6 7 8 var count = 0 while yes # yes is always yes, so this will loop indefinitely count++ break count # 1 The return statement can only be used inside methods or do blocks as it doesn't really terminate the while loop, but returns from the method or do block completely. While looping inside a while loop, we can use continue to skip the rest of the block. It's basically like jumping back to the top of the block. 1 2 3 4 5 6 7 var evenNumbers = [] var i = 0 while i++ < 200 if i % 2 continue evenNumbers.push i The until loop \u00b6 The until loop is similar to the while loop, with a reverse condition: it will stop only once the condition is met. It is just a shorter way to say while not condition . 1 2 3 4 var baloons = [1, 2, 3, 4, 5] until baloons:length is 0 baloons.pop We can use break , return and continue inside until just like in the while loops. The for loop \u00b6 Whereas the while and until loops are more generic, for loop is used specifically for iterating over array members and object properties. There are two variants of for loops: for ... in for arrays, strings, and array-like objects. for ... of for object properties. The for ... in loop is used like this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 var colorIndex = { R: '#ff0000' G: '#00ff00' B: '#0000ff' C: '#00ffff' M: '#ff00ff' Y: '#ffff00' } var colorSequence = ['R', 'M', 'R', 'G', 'B', 'C', 'M'] var colors = [] for colorKey in colorSequence colors.push colorIndex[colorKey] For loops are actually arrays, and they can be assigned and passed. In the previous example we kept pushing into the colors array. This can be written simply like so: 1 2 var colors = for colorKey in colorSequence colorIndex[colorKey] In for loops, we can also access the the indices of members we are iterating over. 1 2 3 var colors = for colorKey, index in colorSequence intensity: (index + 1) * 100 color: colorIndex[colorKey] The for ... of loop is used for objects. In it's simpler form, for ... of iterates over the keys. 1 2 3 4 5 6 7 8 9 10 11 var colorIndex = { R: '#ff0000' G: '#00ff00' B: '#0000ff' C: '#00ffff' M: '#ff00ff' Y: '#ffff00' } var allColors = for key of colorIndex key We can also use for ... of to iterate over both keys and values. 1 2 3 4 var reverseIndex = {} for key, val of colorIndex reverseIndex[val] = key Just like the while loop, we can use break , return and continue to terminate the loop or skip iterations. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var player = [ {name: 'OP', dmg: 400, hp: 100} {name: 'Nuclear', dmg: 300, hp: 200} {name: 'Voe': dmg: 280, hp: 210} {name: 'Polygon', dmg: 220, hp: 180} {name: 'Glitter', dmg: 440, hp: 120} {name: 'Vanilla J', dmg: 300, hp: 50} ] var strongPlayers = for player in players if player:dmg < 300 continue else player:name strongPlayers # ['OP', 'Glitter', 'Vanilla J']","title":"Control structures - if, try, for, while, until"},{"location":"lvl1/controls/#control-structures-if-try-for-while-until","text":"Control structures control the flow of execution by providing mechanism for branching and repeating execution of code. Imba has several different control structures. if blocks control branching try blocks handle exceptions loops ( for , while , until ) allow repetitive execution of code blocks","title":"Control structures - if, try, for, while, until"},{"location":"lvl1/controls/#cheats","text":"Imba has the if , try , while , until and for blocks. All blocks are expressions which can be assigned and passed around. There are no parentheses around conditions. There is no punctuation in blocks (e.g., if x ). if block can have else if and else branches. for , white , until can be passed and assigned as arrays. for , white , until can break and continue . for x in arr or for x, idx in arr to loop over arrays. for key of obj or for key, val of obj to loop over object properties. There is no for i; i < j; i++ version of for loop in Imba. catch is optional in try block.","title":"Cheats"},{"location":"lvl1/controls/#the-if-block","text":"Sometimes we want to do different things depending on some condition. For instance, 'if user is logged in, show them the profile page, and otherwise take them to the log in page.' Just like the name suggests, the if blocks are only evaluated if some condition is met. The condition can be any valid Imba expression, including any of the control blocks found in this section (yes, if block itself, too!). For example: 1 2 3 4 var lives = 0 if lives is 0 'You are dead' We can also specify what happens in the other case: 1 2 3 4 5 6 7 var lives = 3 if lives is 0 'You are dead' else lives -= 1 \"You have {lives} more lives\" The if block is not restricted to just if and else branches. One or more additional conditions can be specified as else if branches. For example: 1 2 3 4 5 6 7 8 9 10 var lives = 3 if lives is 0 'You are dead' else if lives is 1 lives -= 1 'You are mine next time!' else lives -= 1 \"You have {lives} more lives\". If blocks can be assigned to variables. 1 2 3 4 5 6 7 8 9 10 var lives = 3 var x = if lives is 0 'You are dead' else lives -= 1 \"You have {lives} more lives\" x # \"You have 2 more lives\"","title":"The if block"},{"location":"lvl1/controls/#ternary-expression","text":"In some cases, we can write the if block as a ternary expression to save space. Ternary expression is not technically a control structure, but we will mention it here because we don't have a better things to do anyway. 1 2 var lives = 3 var isDead = if lives is 0 then yes else no The else if branches cannot be used in ternary expressions.","title":"Ternary expression"},{"location":"lvl1/controls/#the-try-block","text":"Perfectly valid code will sometimes throw exceptions. Exceptions are objects generated by some error condition or thrown by some code. Exception objects will propagate through the application from the point where it was thrown, then back up through the path that lead to the point. If it is not caught somewhere on the path, it will eventually reach the JavaScript engine itself, and be treated as an 'uncaught' exception. (This is usually going to show up as a traceback in the developer console or in the terminal.) 1 2 3 4 5 6 7 def foogGun throw Error 'bug!' try footGun catch e console.log \"That was close! Let's do it again!\" The e variable in the catch branch is the error object that was thrown by the footGun method. Note that the catch branch is optional . If we simply wish to suppress an exception without doing anything, we can completely omit it. 1 2 3 try fooGun # Look, mom, no catch! Like if blocks, the try block can be assigned 1 2 3 4 var afermath = try footGun catch e 'Feeling exceptionally good!'","title":"The try block"},{"location":"lvl1/controls/#the-while-loop","text":"The while loop is the simplest control structure for repeating blocks of code. It repeats the block while some condition is met, hence the name. 1 2 3 4 var bullets = 1000 white bullets > 0 bullets-- Other than letting the while loop run until the condition no longer applies, we can also end it prematurely by using the break or return statements. 1 2 3 4 5 6 7 8 var count = 0 while yes # yes is always yes, so this will loop indefinitely count++ break count # 1 The return statement can only be used inside methods or do blocks as it doesn't really terminate the while loop, but returns from the method or do block completely. While looping inside a while loop, we can use continue to skip the rest of the block. It's basically like jumping back to the top of the block. 1 2 3 4 5 6 7 var evenNumbers = [] var i = 0 while i++ < 200 if i % 2 continue evenNumbers.push i","title":"The while loop"},{"location":"lvl1/controls/#the-until-loop","text":"The until loop is similar to the while loop, with a reverse condition: it will stop only once the condition is met. It is just a shorter way to say while not condition . 1 2 3 4 var baloons = [1, 2, 3, 4, 5] until baloons:length is 0 baloons.pop We can use break , return and continue inside until just like in the while loops.","title":"The until loop"},{"location":"lvl1/controls/#the-for-loop","text":"Whereas the while and until loops are more generic, for loop is used specifically for iterating over array members and object properties. There are two variants of for loops: for ... in for arrays, strings, and array-like objects. for ... of for object properties. The for ... in loop is used like this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 var colorIndex = { R: '#ff0000' G: '#00ff00' B: '#0000ff' C: '#00ffff' M: '#ff00ff' Y: '#ffff00' } var colorSequence = ['R', 'M', 'R', 'G', 'B', 'C', 'M'] var colors = [] for colorKey in colorSequence colors.push colorIndex[colorKey] For loops are actually arrays, and they can be assigned and passed. In the previous example we kept pushing into the colors array. This can be written simply like so: 1 2 var colors = for colorKey in colorSequence colorIndex[colorKey] In for loops, we can also access the the indices of members we are iterating over. 1 2 3 var colors = for colorKey, index in colorSequence intensity: (index + 1) * 100 color: colorIndex[colorKey] The for ... of loop is used for objects. In it's simpler form, for ... of iterates over the keys. 1 2 3 4 5 6 7 8 9 10 11 var colorIndex = { R: '#ff0000' G: '#00ff00' B: '#0000ff' C: '#00ffff' M: '#ff00ff' Y: '#ffff00' } var allColors = for key of colorIndex key We can also use for ... of to iterate over both keys and values. 1 2 3 4 var reverseIndex = {} for key, val of colorIndex reverseIndex[val] = key Just like the while loop, we can use break , return and continue to terminate the loop or skip iterations. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var player = [ {name: 'OP', dmg: 400, hp: 100} {name: 'Nuclear', dmg: 300, hp: 200} {name: 'Voe': dmg: 280, hp: 210} {name: 'Polygon', dmg: 220, hp: 180} {name: 'Glitter', dmg: 440, hp: 120} {name: 'Vanilla J', dmg: 300, hp: 50} ] var strongPlayers = for player in players if player:dmg < 300 continue else player:name strongPlayers # ['OP', 'Glitter', 'Vanilla J']","title":"The for loop"},{"location":"lvl1/do/","text":"Do block \u00b6 Do blocks are ad-hoc methods. They are similar to methods in that they represent parametrized blocks of code. Unlike methods, do blocks are expressions, so they are treated as values rather than declarations. On their own, they do not have a name we can refer to, nor means of invoking them. In other languages, do blocks appear under names like 'function expression' or 'lambda'. Do blocks are usually used when a function or a method needs a function or a method as an argument. Cheats \u00b6 do blocks compile to function expressions in JavaScript. The do block syntax is do |x, y, z| body . Parameters delimited by bars | | are optional. The body can be one line or multiple lines. self inside a do block refers to the self in the outer scope. this inside a do block is a normal this . Named function declarations are written similarly to methods, but with var def instead of def . Writing do blocks \u00b6 The syntax of the do block looks very different compared to methods, but the basic structure is the same. Here is a method: 1 2 def add x, y x + y Here is an equivalent do block: 1 var add = do |x, y| x + y Do blocks have all the features that methods do, like optional and rest parameters. Using do blocks as callbacks \u00b6 Do blocks are most commonly used as callbacks in methods and functions. While declared methods or imported functions can also be used as callbacks, do blocks have an advantage of being ad-hoc. They can be defined on the spot as one-off callbacks. Here is an example of using a method as a callback: 1 2 3 4 def afterSave assets game.start assets, config loadAssets self:afterSave If we rewrite the above using a do block it looks like this: 1 loadAssets do |assets| game.start assets, config Using & placeholder \u00b6 In some cases callbacks are not conveniently the last parameter. The setTimeout and setInterval built-in functions are good examples. 1 2 3 setInterval do gameTimer.update Date.now , 100 The & character can be used as a placeholder in such cases, to allow us to supply the callback last. This requires parentheses around all parameters. 1 setInterval(&, 100) do gameTimer.update Date.now Note If you come from a functional programming background, this may look like partial application. During compilation, Imba actually replaces the placeholder with the callback in the resulting code so it's not doing any partial application, and there is no penalty for using this syntax. Using do blocks to write higher order methods \u00b6 Higher order functions are functions that take functions as arguments or return them. We have already seen an example of a higher order function that take other functions as arguments in the setInterval example in this section, where we use a do block as an argument. Do blocks can also be very useful when we want to write methods that are higher order functions (a.k.a. higher order methods). Because declaring a method also creates a property on the self object, declaring new methods inside other methods may sometimes yield unexpected results, and can create properties we don't really need. Because of this, it is usually preferred to use do blocks instead. Consider the following method. 1 2 3 4 5 6 7 8 def drawShape screen, shape screen.save screen.draw shape screen.restore drawShape screen, triangle drawShape screen, rectangle drawShape screen, machoDudeWithTagsAsArms If we use this method throughout our program, and there is only one screen that we draw to, it may seem like a bad idea to keep supplying screen object every time we call drawShape . We can solve this by converting the drawShape into a higher order method: 1 2 3 4 5 6 7 8 9 10 11 def drawShape screen do |shape| screen.save screen.draw shape screen.restore var drawToScreen = drawShape screen drawToScreen triangle drawToScreen rectangle drawToScreen machoDudeWithTagsAsArms Note The technique in the last example is called currying . Do blocks and self \u00b6 The self object inside a do block always refers to the self in the outer scope. 1 2 3 4 5 6 7 def keyHandlerFor code # .... def attachEventHandler target target.addEventListener 'keydown', do |event| var keyHandler = self.keyHandlerFor event.keyCode keyHandler In this example, the self.keyHandler refers to a method on the same self object on which attachEventHandler is declared. Note You probably notice that we do not really need to use self. in the last example. It's just there to make it explicit and clear. Even if we omit self. , it makes no difference because Imba always treats undeclared names as methods on the self object. Function declarations \u00b6 In the very first example in this section, we have seen a do block that was assigned to a variable. This pattern can be written using var def declarations. Although var def declarations look similar to method declarations, they are semantically closer to do blocks. Let's take a look at the first example again: 1 var add = do |x, y| x + y Here is a version that is rewritten using var def . 1 2 var def add x, y x + y Warning Function declarations are not subject to hoisting in Imba even if it may seem so just looking at the compiler output. Calling a var def function above the point of declaration will cause the compiler to treat the reference as a method call on the self object. The example of the drawShape higher order method can also be rewritten using function declarations: 1 2 3 4 5 def drawShape screen var def draw shape screen.save screen.draw shape screen.restore There is no practical difference between the original drawShape and this one in this particular case, but the main difference is that the inner function has a name, unlike do blocks. This is an important property when it comes to recursive functions .","title":"Do block"},{"location":"lvl1/do/#do-block","text":"Do blocks are ad-hoc methods. They are similar to methods in that they represent parametrized blocks of code. Unlike methods, do blocks are expressions, so they are treated as values rather than declarations. On their own, they do not have a name we can refer to, nor means of invoking them. In other languages, do blocks appear under names like 'function expression' or 'lambda'. Do blocks are usually used when a function or a method needs a function or a method as an argument.","title":"Do block"},{"location":"lvl1/do/#cheats","text":"do blocks compile to function expressions in JavaScript. The do block syntax is do |x, y, z| body . Parameters delimited by bars | | are optional. The body can be one line or multiple lines. self inside a do block refers to the self in the outer scope. this inside a do block is a normal this . Named function declarations are written similarly to methods, but with var def instead of def .","title":"Cheats"},{"location":"lvl1/do/#writing-do-blocks","text":"The syntax of the do block looks very different compared to methods, but the basic structure is the same. Here is a method: 1 2 def add x, y x + y Here is an equivalent do block: 1 var add = do |x, y| x + y Do blocks have all the features that methods do, like optional and rest parameters.","title":"Writing do blocks"},{"location":"lvl1/do/#using-do-blocks-as-callbacks","text":"Do blocks are most commonly used as callbacks in methods and functions. While declared methods or imported functions can also be used as callbacks, do blocks have an advantage of being ad-hoc. They can be defined on the spot as one-off callbacks. Here is an example of using a method as a callback: 1 2 3 4 def afterSave assets game.start assets, config loadAssets self:afterSave If we rewrite the above using a do block it looks like this: 1 loadAssets do |assets| game.start assets, config","title":"Using do blocks as callbacks"},{"location":"lvl1/do/#using-placeholder","text":"In some cases callbacks are not conveniently the last parameter. The setTimeout and setInterval built-in functions are good examples. 1 2 3 setInterval do gameTimer.update Date.now , 100 The & character can be used as a placeholder in such cases, to allow us to supply the callback last. This requires parentheses around all parameters. 1 setInterval(&, 100) do gameTimer.update Date.now Note If you come from a functional programming background, this may look like partial application. During compilation, Imba actually replaces the placeholder with the callback in the resulting code so it's not doing any partial application, and there is no penalty for using this syntax.","title":"Using &amp; placeholder"},{"location":"lvl1/do/#using-do-blocks-to-write-higher-order-methods","text":"Higher order functions are functions that take functions as arguments or return them. We have already seen an example of a higher order function that take other functions as arguments in the setInterval example in this section, where we use a do block as an argument. Do blocks can also be very useful when we want to write methods that are higher order functions (a.k.a. higher order methods). Because declaring a method also creates a property on the self object, declaring new methods inside other methods may sometimes yield unexpected results, and can create properties we don't really need. Because of this, it is usually preferred to use do blocks instead. Consider the following method. 1 2 3 4 5 6 7 8 def drawShape screen, shape screen.save screen.draw shape screen.restore drawShape screen, triangle drawShape screen, rectangle drawShape screen, machoDudeWithTagsAsArms If we use this method throughout our program, and there is only one screen that we draw to, it may seem like a bad idea to keep supplying screen object every time we call drawShape . We can solve this by converting the drawShape into a higher order method: 1 2 3 4 5 6 7 8 9 10 11 def drawShape screen do |shape| screen.save screen.draw shape screen.restore var drawToScreen = drawShape screen drawToScreen triangle drawToScreen rectangle drawToScreen machoDudeWithTagsAsArms Note The technique in the last example is called currying .","title":"Using do blocks to write higher order methods"},{"location":"lvl1/do/#do-blocks-and-self","text":"The self object inside a do block always refers to the self in the outer scope. 1 2 3 4 5 6 7 def keyHandlerFor code # .... def attachEventHandler target target.addEventListener 'keydown', do |event| var keyHandler = self.keyHandlerFor event.keyCode keyHandler In this example, the self.keyHandler refers to a method on the same self object on which attachEventHandler is declared. Note You probably notice that we do not really need to use self. in the last example. It's just there to make it explicit and clear. Even if we omit self. , it makes no difference because Imba always treats undeclared names as methods on the self object.","title":"Do blocks and self"},{"location":"lvl1/do/#function-declarations","text":"In the very first example in this section, we have seen a do block that was assigned to a variable. This pattern can be written using var def declarations. Although var def declarations look similar to method declarations, they are semantically closer to do blocks. Let's take a look at the first example again: 1 var add = do |x, y| x + y Here is a version that is rewritten using var def . 1 2 var def add x, y x + y Warning Function declarations are not subject to hoisting in Imba even if it may seem so just looking at the compiler output. Calling a var def function above the point of declaration will cause the compiler to treat the reference as a method call on the self object. The example of the drawShape higher order method can also be rewritten using function declarations: 1 2 3 4 5 def drawShape screen var def draw shape screen.save screen.draw shape screen.restore There is no practical difference between the original drawShape and this one in this particular case, but the main difference is that the inner function has a name, unlike do blocks. This is an important property when it comes to recursive functions .","title":"Function declarations"},{"location":"lvl1/methods/","text":"Methods \u00b6 Methods are reusable blocks of code that can be applied to its arguments. Methods are similar to mathematical functions, although they are not strictly the same thing. In other languages, Imba methods are known as 'functions', 'procedures', and 'subroutines'. While these things may have slightly different meanings to different programmers, they all serve the same purpose. Methods are used to reduce duplication where similar or identical behavior is used in different parts of a program. They are identified by a name, parameters that serve as placeholders for arguments passed to them, and the method body, which is the code that belongs to a method. The best way to think of methods is 'configurable named code blocks'. They can be configured using parameters, and they are packaged into a named method so you can easily refer to it by name without retyping the entire block again and again. Cheats \u00b6 Syntax for defining methods is def methodName x, y, z Methods in module scope are literally methods, not stand-alone functions. Methods in module scope are methods on a self object which is an object in the private module scope. Methods can reference each other in the module via the self of this objects. The rest spread ...args is written as *args . Optional arguments can be given a default value with arg = exp syntax. Default values of optional arguments apply even when undefined is passed explicitly. Parenthesis around arguments are optional even when there are no arguments. Basic syntax \u00b6 Here is a simple method that has no parameters. 1 2 def completeDenial no To use this method we call it. Since the method completeDenial has no arguments it can be called simply by referencing its name in the code: 1 completeDenial If you have programmed in another language, you may think that this is what's commonly known as a 'function', but in Imba, these are real methods. They are methods on an object called self . We can call the completeDenial method like this as well: 1 self.completeDenial Method parameters \u00b6 As mentioned at the beginning of this section, methods can have parameters. Parameters are used to configure how a method operates or pass it values to operate on. Here is a method that takes two parameters. 1 2 def add x, y x + y To call the method add , we reference its name, and we also supply values to it by listing the values after the name of the function. 1 2 add 1, 2 # 3 The values that were given (or 'passed') to add are also called 'arguments', so we can say that 'we passed arguments 1 and 2 to add .' The vales 1 and 2 are bound to names x and y in the function. The code of the method body is then evaluated, and the value of the last expression ( x + y ) is returned. Method return value \u00b6 Methods have a return value. The return value of a method is the last statement in the method. In the case of completeDenial , the return value is no as it is the last (and only) expression that evaluated. This is called an 'implicit return'. The return statement can be used to explicitly return a value. Here is an example of a function that returns a value explicitly. 1 2 3 4 5 6 7 var ammo = 100 var cheatsEnabled = yes def shoot if cheatsEnabled return ammo ammo -= 1 In the above method, we have two statements, the if block and ammo . Since the return value is always the last statement, we have to use return to short-circuit the function if we want to return from within the if block. Alternatively, we can make the if block the last statement by including the else clause. This gets rid of the return statement. 1 2 3 4 5 6 7 8 var ammo = 100 var cheatsEnabled = yes def shoot if cheatsEnabled ammo else ammo -= 1 In the section about control structures , we have briefly talked about using return to short-circuit a loop inside methods. When using a return statement inside a loop, the method returns immediately, just like with if blocks. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 var battery = { capacity: 200 charge: 15 } def charge batt, amount while amount batt:charge += 1 if batt:charge > batt:capacity return \"Blown!\" \"Charged\" charge battery, 500 # \"Blown!\" It's important to keep in mind what happens if we short-circuit return from a loop when loop is the last statement in a method. For example: 1 2 3 4 5 6 7 8 9 10 11 12 def brokenRange x var i = 1 while i < x if (i > 50) return i i brokenRange 100 # 51 brokenRange 5 # [1, 2, 3, 4] Optional parameters \u00b6 One or more parameters in a method can be made optional. This is done by assigning a default value to a parameter. 1 2 def bang text, puncutation = '!' text + punctuation The parameter punctuation will have a default value of '!' if no values are bound to it, or if the value bound to it is undefined (more on this special value later). 1 2 var excessiveGreating = bang 'Hello' var normalGreeting = bang 'Hello', '.' In the example, excessiveGreeting will be 'Hello!' , because the second value is omitted. Destructured parameters \u00b6 When objects are passed to methods, they can be destructured with default values. This is done by writing one or more key-value pairs in place of a parameter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def heal player, intensity: 5 player:hp += intensity var player = { hp: 10 mp: 200 dmg: 500 } var potion = { intensity: 40 } heal player, potion player:hp # 50 Parentheses around key-value pairs are optional. The default value is used when a key is not found on the object. 1 2 3 heal player, {} player:hp # 55 If a non-object is passed for a destructured parameter, it will be treated as the default value is used for the destructured keys. 1 2 3 heal player, null player:hp # 60 Callback parameter \u00b6 Methods can declare their last parameter explicitly as a callback using the & prefix. 1 2 3 4 5 def saveGame filename, overwrite = no, &callback if overwrite is no and fileExists filename callback 'error' writeFile filename, gameState callback() With the callback parameter defined with the & parameter, when a do block or a method is passed to saveGame , it will know to bind the last argument correctly to the callback parameter even if overwrite is skipped. 1 2 3 saveGame '001.sav', do |error| if error showError Without the & prefix, the second argument would be treated as the overwrite argument. This callback parameter only has an effect when there are optional parameters. Rest parameters \u00b6 Methods can be declared with rest parameters which capture any parameters that are not explicitly declared. The rest parameter is declared using a * followed by the name given to an array of captured parameters. 1 2 3 4 5 def equip player, *weapons for weapon in weapons player.equal weapon equip player, 'sword', 'laser gun', 'onion' Referencing methods as objects \u00b6 Just like any other value in JavaScript, methods are also objects. They can be assigned and passed to other methods and functions as arguments. We already mentioned that methods, when referenced by name, are immediately called. When we want to use them as values instead of calling them, we need to prefix the method name with self: . 1 2 3 4 5 def increment x x + 1 [1, 2, 3].map self:increment # [2, 3, 4] Declaring methods in object literals \u00b6 Methods can be declared inside object literals. 1 2 3 4 5 6 var laserGun = { ammo: 1000 dmg: 50 def shoot \"Woosh!\" } This creates a property on the object that has a key matching the method name. Methods defined in object literals can be called using the object.key notation. 1 2 laserGun.shoot # \"Woosh!\" When defined inside object literals, we can use self to refer to the object to which the method belongs. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var laserGun = { ammo: 1000 dmg: 50 def shoot target self:ammo -= 1 target:hp -= self:dmg } var badPerson = { hp: 100 } laserGun.shoot badPerson badPerson:hp # 50 When we want to use the method as a value, we can reference it using the : operator. 1 var shoot = laserGun:shoot In Imba, all methods are unbound. This means that they are not hard-wired to the objects to which they belong. To demonstrate this we will use the shoot variable we have defined earlier to shoot another target. 1 2 3 4 5 6 var anotherTarget = { hp: 50 } shoot anotherTarget # TypeError: this is undefined What happened is that shoot is unbound, so self is undefined . Attempting to decrease the value of self:ammo threw a TypeError exception. This is the result of what is know as 'invocation context'. Methods are called as bound only when we specify the object on which they are called using object.key notation. In the last example, we did not use the . anywhere so the method was called unbound (it's invocation context was undefined ). Note Also read about .bind , .call and .apply methods for different ways to control the invocation context. Declaring methods within methods \u00b6 Methods can be declared anywhere, including inside other methods. However, declaring a method within another method can be a bit tricky to wrap one's head around. The important thing to remember is that a method is declared as a property on self . Consider this example. 1 2 3 4 5 6 def outer def inner 'Hello from inner' var x = outer var y = inner The outer method, when called, defines the inner method. Since def inner is the last statement in outer , that is also its return value. Therefore, x is the inner method. Inside the outer method, self is the same self on which outer itself is defined. Because of this, inner is also defined on the same self . In other words, self now looks like this: 1 2 3 4 5 6 7 8 var self = { def outer def inner console.log 'Hello from inner' def inner console.log 'Hello from inner' } The way to think about this is that outer is a method that creates the inner . We are now able to call inner just by referencing inner , so the value of y is 'Hello from inner' . If we take this one step further, it means that outer can also redefine inner if it is already defined . Let's take a look at a modified example: 1 2 3 4 5 6 7 8 9 def inner 'I was here first' def outer def inner 'No, I was here first!' outer var whoWasFirst = inner The value of whoWasFirst is 'No, I was here first!' . Method type \u00b6 All methods are objects of type 'function'. Useful methods and properties \u00b6 Note It may sound strange, but methods have their own methods and properties, because they are themselves objects. :length :name .apply .bind .call .toString","title":"Methods"},{"location":"lvl1/methods/#methods","text":"Methods are reusable blocks of code that can be applied to its arguments. Methods are similar to mathematical functions, although they are not strictly the same thing. In other languages, Imba methods are known as 'functions', 'procedures', and 'subroutines'. While these things may have slightly different meanings to different programmers, they all serve the same purpose. Methods are used to reduce duplication where similar or identical behavior is used in different parts of a program. They are identified by a name, parameters that serve as placeholders for arguments passed to them, and the method body, which is the code that belongs to a method. The best way to think of methods is 'configurable named code blocks'. They can be configured using parameters, and they are packaged into a named method so you can easily refer to it by name without retyping the entire block again and again.","title":"Methods"},{"location":"lvl1/methods/#cheats","text":"Syntax for defining methods is def methodName x, y, z Methods in module scope are literally methods, not stand-alone functions. Methods in module scope are methods on a self object which is an object in the private module scope. Methods can reference each other in the module via the self of this objects. The rest spread ...args is written as *args . Optional arguments can be given a default value with arg = exp syntax. Default values of optional arguments apply even when undefined is passed explicitly. Parenthesis around arguments are optional even when there are no arguments.","title":"Cheats"},{"location":"lvl1/methods/#basic-syntax","text":"Here is a simple method that has no parameters. 1 2 def completeDenial no To use this method we call it. Since the method completeDenial has no arguments it can be called simply by referencing its name in the code: 1 completeDenial If you have programmed in another language, you may think that this is what's commonly known as a 'function', but in Imba, these are real methods. They are methods on an object called self . We can call the completeDenial method like this as well: 1 self.completeDenial","title":"Basic syntax"},{"location":"lvl1/methods/#method-parameters","text":"As mentioned at the beginning of this section, methods can have parameters. Parameters are used to configure how a method operates or pass it values to operate on. Here is a method that takes two parameters. 1 2 def add x, y x + y To call the method add , we reference its name, and we also supply values to it by listing the values after the name of the function. 1 2 add 1, 2 # 3 The values that were given (or 'passed') to add are also called 'arguments', so we can say that 'we passed arguments 1 and 2 to add .' The vales 1 and 2 are bound to names x and y in the function. The code of the method body is then evaluated, and the value of the last expression ( x + y ) is returned.","title":"Method parameters"},{"location":"lvl1/methods/#method-return-value","text":"Methods have a return value. The return value of a method is the last statement in the method. In the case of completeDenial , the return value is no as it is the last (and only) expression that evaluated. This is called an 'implicit return'. The return statement can be used to explicitly return a value. Here is an example of a function that returns a value explicitly. 1 2 3 4 5 6 7 var ammo = 100 var cheatsEnabled = yes def shoot if cheatsEnabled return ammo ammo -= 1 In the above method, we have two statements, the if block and ammo . Since the return value is always the last statement, we have to use return to short-circuit the function if we want to return from within the if block. Alternatively, we can make the if block the last statement by including the else clause. This gets rid of the return statement. 1 2 3 4 5 6 7 8 var ammo = 100 var cheatsEnabled = yes def shoot if cheatsEnabled ammo else ammo -= 1 In the section about control structures , we have briefly talked about using return to short-circuit a loop inside methods. When using a return statement inside a loop, the method returns immediately, just like with if blocks. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 var battery = { capacity: 200 charge: 15 } def charge batt, amount while amount batt:charge += 1 if batt:charge > batt:capacity return \"Blown!\" \"Charged\" charge battery, 500 # \"Blown!\" It's important to keep in mind what happens if we short-circuit return from a loop when loop is the last statement in a method. For example: 1 2 3 4 5 6 7 8 9 10 11 12 def brokenRange x var i = 1 while i < x if (i > 50) return i i brokenRange 100 # 51 brokenRange 5 # [1, 2, 3, 4]","title":"Method return value"},{"location":"lvl1/methods/#optional-parameters","text":"One or more parameters in a method can be made optional. This is done by assigning a default value to a parameter. 1 2 def bang text, puncutation = '!' text + punctuation The parameter punctuation will have a default value of '!' if no values are bound to it, or if the value bound to it is undefined (more on this special value later). 1 2 var excessiveGreating = bang 'Hello' var normalGreeting = bang 'Hello', '.' In the example, excessiveGreeting will be 'Hello!' , because the second value is omitted.","title":"Optional parameters"},{"location":"lvl1/methods/#destructured-parameters","text":"When objects are passed to methods, they can be destructured with default values. This is done by writing one or more key-value pairs in place of a parameter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def heal player, intensity: 5 player:hp += intensity var player = { hp: 10 mp: 200 dmg: 500 } var potion = { intensity: 40 } heal player, potion player:hp # 50 Parentheses around key-value pairs are optional. The default value is used when a key is not found on the object. 1 2 3 heal player, {} player:hp # 55 If a non-object is passed for a destructured parameter, it will be treated as the default value is used for the destructured keys. 1 2 3 heal player, null player:hp # 60","title":"Destructured parameters"},{"location":"lvl1/methods/#callback-parameter","text":"Methods can declare their last parameter explicitly as a callback using the & prefix. 1 2 3 4 5 def saveGame filename, overwrite = no, &callback if overwrite is no and fileExists filename callback 'error' writeFile filename, gameState callback() With the callback parameter defined with the & parameter, when a do block or a method is passed to saveGame , it will know to bind the last argument correctly to the callback parameter even if overwrite is skipped. 1 2 3 saveGame '001.sav', do |error| if error showError Without the & prefix, the second argument would be treated as the overwrite argument. This callback parameter only has an effect when there are optional parameters.","title":"Callback parameter"},{"location":"lvl1/methods/#rest-parameters","text":"Methods can be declared with rest parameters which capture any parameters that are not explicitly declared. The rest parameter is declared using a * followed by the name given to an array of captured parameters. 1 2 3 4 5 def equip player, *weapons for weapon in weapons player.equal weapon equip player, 'sword', 'laser gun', 'onion'","title":"Rest parameters"},{"location":"lvl1/methods/#referencing-methods-as-objects","text":"Just like any other value in JavaScript, methods are also objects. They can be assigned and passed to other methods and functions as arguments. We already mentioned that methods, when referenced by name, are immediately called. When we want to use them as values instead of calling them, we need to prefix the method name with self: . 1 2 3 4 5 def increment x x + 1 [1, 2, 3].map self:increment # [2, 3, 4]","title":"Referencing methods as objects"},{"location":"lvl1/methods/#declaring-methods-in-object-literals","text":"Methods can be declared inside object literals. 1 2 3 4 5 6 var laserGun = { ammo: 1000 dmg: 50 def shoot \"Woosh!\" } This creates a property on the object that has a key matching the method name. Methods defined in object literals can be called using the object.key notation. 1 2 laserGun.shoot # \"Woosh!\" When defined inside object literals, we can use self to refer to the object to which the method belongs. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var laserGun = { ammo: 1000 dmg: 50 def shoot target self:ammo -= 1 target:hp -= self:dmg } var badPerson = { hp: 100 } laserGun.shoot badPerson badPerson:hp # 50 When we want to use the method as a value, we can reference it using the : operator. 1 var shoot = laserGun:shoot In Imba, all methods are unbound. This means that they are not hard-wired to the objects to which they belong. To demonstrate this we will use the shoot variable we have defined earlier to shoot another target. 1 2 3 4 5 6 var anotherTarget = { hp: 50 } shoot anotherTarget # TypeError: this is undefined What happened is that shoot is unbound, so self is undefined . Attempting to decrease the value of self:ammo threw a TypeError exception. This is the result of what is know as 'invocation context'. Methods are called as bound only when we specify the object on which they are called using object.key notation. In the last example, we did not use the . anywhere so the method was called unbound (it's invocation context was undefined ). Note Also read about .bind , .call and .apply methods for different ways to control the invocation context.","title":"Declaring methods in object literals"},{"location":"lvl1/methods/#declaring-methods-within-methods","text":"Methods can be declared anywhere, including inside other methods. However, declaring a method within another method can be a bit tricky to wrap one's head around. The important thing to remember is that a method is declared as a property on self . Consider this example. 1 2 3 4 5 6 def outer def inner 'Hello from inner' var x = outer var y = inner The outer method, when called, defines the inner method. Since def inner is the last statement in outer , that is also its return value. Therefore, x is the inner method. Inside the outer method, self is the same self on which outer itself is defined. Because of this, inner is also defined on the same self . In other words, self now looks like this: 1 2 3 4 5 6 7 8 var self = { def outer def inner console.log 'Hello from inner' def inner console.log 'Hello from inner' } The way to think about this is that outer is a method that creates the inner . We are now able to call inner just by referencing inner , so the value of y is 'Hello from inner' . If we take this one step further, it means that outer can also redefine inner if it is already defined . Let's take a look at a modified example: 1 2 3 4 5 6 7 8 9 def inner 'I was here first' def outer def inner 'No, I was here first!' outer var whoWasFirst = inner The value of whoWasFirst is 'No, I was here first!' .","title":"Declaring methods within methods"},{"location":"lvl1/methods/#method-type","text":"All methods are objects of type 'function'.","title":"Method type"},{"location":"lvl1/methods/#useful-methods-and-properties","text":"Note It may sound strange, but methods have their own methods and properties, because they are themselves objects. :length :name .apply .bind .call .toString","title":"Useful methods and properties"},{"location":"lvl1/objects/","text":"Objects \u00b6 Objects are simple collections of properties. Once created, objects can be freely modified by reassigning values to existing properties, adding new properties or removing properties. Due to their lightweight syntax, Objects in JavaScript can be used as simple associative arrays, hashmaps, or dicts found in other languages. Warning Objects created using native Imba classes are different than objects created using JavaScript constructors. Classes are covered in level 2 . Cheats \u00b6 Objects behave the same way as in JavaScript but with differences in syntax. Syntactically valid JavaScript object literal is valid in Imba. Commas , are not needed when properties are listed vertically. Braces are optional if objects are used as arguments. Braces are optional when nested under properties in object literals. Properties are accessed with x:key . Methods are called with x.key (parentheses are optional even with no arguments). Property access on a potentially nullable object is done with x?:key . Method call on a potentially nullable object is done with x?:key . Computed member access x[expr] works like in JavaScript. Can assign default value to properties with x:key ?= y . Object properties can be iterated with for key of obj or for key, val of obj Object literals \u00b6 The simplest way to create an object is the object literal syntax. This may come as a surprise to programmers coming from object-oriented languages where objects must be instantiated using classes. While objects in Imba can also be instantiated using classes, there is very little difference between such objects and objects created using the object literal syntax. 1 2 3 4 5 var player = { score: 0 lives: 3 ammo: 100 } An object literal is surrounded by a set of curly braces { } . Inside the curly braces, zero or more key-value pairs are listed. These are known as object properties. Each property consists of a key name, a colon : , and a value. If a key is present, it must have a value. Warning If you are used to JavaScript objects, please note that commas are optional when listing object keys vertically. A key is always a string, and values are of any type. When multiple properties are written on the same line, they are separated by commas: 1 var gun = { type: 'ranged', power: 120, durability: 0.2 } An empty object literal is simply a pair of curly braces with no content. 1 var dead = {} Object literals can sometimes be written without curly braces. This is the case in the following situations: When nesting objects inside other object literals. Used as an argument to a method or a function. In the following example, hotspot property is an object with properties x and y . 1 2 3 4 5 6 7 var level2 = { order: 2 exists: 2 hotspot: x: 12.1 y: 44.2 } In the next example, we are calling a method startGame with a single object that has properties level and player . 1 startGame level: level2, player: player Warning Please note that, unlike JavaScript, there is no shorthand for the cases where keys have the same name as a variable that is used as the value. Properties on objects can be methods or functions (including do blocks). 1 2 3 4 5 6 7 8 var game = { level: level2, player: player, def start screen screen.setLevel self:level screen.setPlayer self:player } Accessing the properties \u00b6 Properties of an object are referenced by its key. There are three ways to access the properties. : - property access . - method access [ ] - computed access The property access operator : is used to access the value of a property. 1 level2:order # evaluates to 2 The method access operator . is used to call a method on an object. 1 game.start screen In the above example, the start method on the game object is called with sreen as an argument. The computed member access allows us to use any valid expression to calculate the key of an object. This includes keys that cannot be used with the usual property and method access operators (e.g., names that contain spaces). 1 2 3 4 game['play' + 'er'] var key = 'level' game[key] If a key does not exist on an object, there is no error. Instead, the accessed property will simply evaluate to undefined . Attempting to access properties on undefined or null is an error, however. Imba provides two operators to safely access properties on nullable objects ( undefined and null ): 1 2 3 4 var possiblyNull = null possiblyNull?:lives # `null` (the value of the object itself) possiblyNull?.go 12, 33 # nothing happens Manipulating objects \u00b6 Properties can be added to objects at any time by simply assigning to them. 1 2 3 4 5 6 7 8 9 10 var nightShadow = { type: 'skill' magic: no stealth: yes effect: 'invisibility' } nightShadow:effectDuration = 2 nightShadow:effectDuration # 2 It is also possible to only assign the default value (that is, only assign a value to a property that does not exist or is nullable). 1 2 3 nightShadow:effectDuration ?= 4 nightShadow:effectDuration # still 2 To delete a property from an object, a delete operator can be used: 1 2 3 delete nightShadow:effectDuration nightShadow:effectDuration # undefined Iterating over object properties \u00b6 We can iterate (loop) over object properties using the for of block. We can either iterate just the keys or both keys and values. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 var dragon = { health: 2000 damage: 500 hp: 240 } for key of dragon console.log key # logs 'health', 'damage', 'hp' for key, val of dragon dragon[key] = val - 100 dragon:health # 1900 dragon:hp # 140 In the next example, we will merge an object into another one by iterating over properties: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var snail = { speed: 2 hp: 1 } var poisonVomit = { damage: 200 specialAbility: 'resist poison' } for key, val of poisonVomit snail[key] = val snail:damage # 200 snail:specialAbility # 'resist poison' You can read more about the for of block in the Control structures section. Mutability and passing by reference \u00b6 Objects are mutable. This means that when they are passed to methods and do blocks, they are passed by reference and any changes made to them are visible both to the method body and the caller. 1 2 3 4 5 6 7 8 9 10 11 12 var player = { score: 0 lives: 3 health: 100 } def hit dmg, player player.health -= dmg hit 30, player console.log player:health # logs 70 The hit method, instead of returning a copy of the player object that is different from the one given to it, changes the player object in place. This is called a 'mutation'. In the example above, the player object was passed to the hit method, and was mutated (changed) within it. However, because it is the same object as the one defined outside the method, we are able to see the effects of the mutation from outside the hit method. This is known as a 'side effect'. It is possible to prevent mutation of objects by using the Object.freeze function. This locks the object so that any attempt to mutate it will result in an error. 1 2 3 Object.freeze player player:score += 100 # error Object identity \u00b6 Two objects are only compared equal if they are the exact same object. In this context 'sameness' does not mean the the contents of the two objects, but whether they point to the same thing in memory. Consider the following examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var player1 = { score: 0 lives: 3 health: 100 } var player2 = { score: 0 lives: 3 health: 100 } var player3 = player1; player1 is player2 # no player1 is player3 # yes Comparing two objects for equality by value requires inspection of individual properties. 1 2 3 4 5 6 7 8 9 10 11 def equalObj x, y if x is y # optimization in case two objects are identical yes else for key, val in x if val isnt y[key] return no yes equalObj player1, player2 # yes equalObj player1, player3 # yes Note The reason this kind of object comparison is not provided out of the box is that it is (a) expensive, and (b) objects can be arbitrarily nested, in which case it becomes even more complex and expensive. Object types and classes \u00b6 All objects have a type 'object' regardless of a class or constructor. To determine whether some object is an instance of a class, we use the isa operator. If we create an object using a Date constructor from the standard JavaScript API, we are able to tell it is a Date object. 1 2 3 4 5 var d = Date.new var notDate = {} d isa Date # yes notDate isa Date # no Note that all objects are ultimately of the class Object because any class or constructor inherits from this class. 1 d isa Object # yes Inheritance will be discussed in more detail in level 2, when we talk about classes .","title":"Objects"},{"location":"lvl1/objects/#objects","text":"Objects are simple collections of properties. Once created, objects can be freely modified by reassigning values to existing properties, adding new properties or removing properties. Due to their lightweight syntax, Objects in JavaScript can be used as simple associative arrays, hashmaps, or dicts found in other languages. Warning Objects created using native Imba classes are different than objects created using JavaScript constructors. Classes are covered in level 2 .","title":"Objects"},{"location":"lvl1/objects/#cheats","text":"Objects behave the same way as in JavaScript but with differences in syntax. Syntactically valid JavaScript object literal is valid in Imba. Commas , are not needed when properties are listed vertically. Braces are optional if objects are used as arguments. Braces are optional when nested under properties in object literals. Properties are accessed with x:key . Methods are called with x.key (parentheses are optional even with no arguments). Property access on a potentially nullable object is done with x?:key . Method call on a potentially nullable object is done with x?:key . Computed member access x[expr] works like in JavaScript. Can assign default value to properties with x:key ?= y . Object properties can be iterated with for key of obj or for key, val of obj","title":"Cheats"},{"location":"lvl1/objects/#object-literals","text":"The simplest way to create an object is the object literal syntax. This may come as a surprise to programmers coming from object-oriented languages where objects must be instantiated using classes. While objects in Imba can also be instantiated using classes, there is very little difference between such objects and objects created using the object literal syntax. 1 2 3 4 5 var player = { score: 0 lives: 3 ammo: 100 } An object literal is surrounded by a set of curly braces { } . Inside the curly braces, zero or more key-value pairs are listed. These are known as object properties. Each property consists of a key name, a colon : , and a value. If a key is present, it must have a value. Warning If you are used to JavaScript objects, please note that commas are optional when listing object keys vertically. A key is always a string, and values are of any type. When multiple properties are written on the same line, they are separated by commas: 1 var gun = { type: 'ranged', power: 120, durability: 0.2 } An empty object literal is simply a pair of curly braces with no content. 1 var dead = {} Object literals can sometimes be written without curly braces. This is the case in the following situations: When nesting objects inside other object literals. Used as an argument to a method or a function. In the following example, hotspot property is an object with properties x and y . 1 2 3 4 5 6 7 var level2 = { order: 2 exists: 2 hotspot: x: 12.1 y: 44.2 } In the next example, we are calling a method startGame with a single object that has properties level and player . 1 startGame level: level2, player: player Warning Please note that, unlike JavaScript, there is no shorthand for the cases where keys have the same name as a variable that is used as the value. Properties on objects can be methods or functions (including do blocks). 1 2 3 4 5 6 7 8 var game = { level: level2, player: player, def start screen screen.setLevel self:level screen.setPlayer self:player }","title":"Object literals"},{"location":"lvl1/objects/#accessing-the-properties","text":"Properties of an object are referenced by its key. There are three ways to access the properties. : - property access . - method access [ ] - computed access The property access operator : is used to access the value of a property. 1 level2:order # evaluates to 2 The method access operator . is used to call a method on an object. 1 game.start screen In the above example, the start method on the game object is called with sreen as an argument. The computed member access allows us to use any valid expression to calculate the key of an object. This includes keys that cannot be used with the usual property and method access operators (e.g., names that contain spaces). 1 2 3 4 game['play' + 'er'] var key = 'level' game[key] If a key does not exist on an object, there is no error. Instead, the accessed property will simply evaluate to undefined . Attempting to access properties on undefined or null is an error, however. Imba provides two operators to safely access properties on nullable objects ( undefined and null ): 1 2 3 4 var possiblyNull = null possiblyNull?:lives # `null` (the value of the object itself) possiblyNull?.go 12, 33 # nothing happens","title":"Accessing the properties"},{"location":"lvl1/objects/#manipulating-objects","text":"Properties can be added to objects at any time by simply assigning to them. 1 2 3 4 5 6 7 8 9 10 var nightShadow = { type: 'skill' magic: no stealth: yes effect: 'invisibility' } nightShadow:effectDuration = 2 nightShadow:effectDuration # 2 It is also possible to only assign the default value (that is, only assign a value to a property that does not exist or is nullable). 1 2 3 nightShadow:effectDuration ?= 4 nightShadow:effectDuration # still 2 To delete a property from an object, a delete operator can be used: 1 2 3 delete nightShadow:effectDuration nightShadow:effectDuration # undefined","title":"Manipulating objects"},{"location":"lvl1/objects/#iterating-over-object-properties","text":"We can iterate (loop) over object properties using the for of block. We can either iterate just the keys or both keys and values. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 var dragon = { health: 2000 damage: 500 hp: 240 } for key of dragon console.log key # logs 'health', 'damage', 'hp' for key, val of dragon dragon[key] = val - 100 dragon:health # 1900 dragon:hp # 140 In the next example, we will merge an object into another one by iterating over properties: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var snail = { speed: 2 hp: 1 } var poisonVomit = { damage: 200 specialAbility: 'resist poison' } for key, val of poisonVomit snail[key] = val snail:damage # 200 snail:specialAbility # 'resist poison' You can read more about the for of block in the Control structures section.","title":"Iterating over object properties"},{"location":"lvl1/objects/#mutability-and-passing-by-reference","text":"Objects are mutable. This means that when they are passed to methods and do blocks, they are passed by reference and any changes made to them are visible both to the method body and the caller. 1 2 3 4 5 6 7 8 9 10 11 12 var player = { score: 0 lives: 3 health: 100 } def hit dmg, player player.health -= dmg hit 30, player console.log player:health # logs 70 The hit method, instead of returning a copy of the player object that is different from the one given to it, changes the player object in place. This is called a 'mutation'. In the example above, the player object was passed to the hit method, and was mutated (changed) within it. However, because it is the same object as the one defined outside the method, we are able to see the effects of the mutation from outside the hit method. This is known as a 'side effect'. It is possible to prevent mutation of objects by using the Object.freeze function. This locks the object so that any attempt to mutate it will result in an error. 1 2 3 Object.freeze player player:score += 100 # error","title":"Mutability and passing by reference"},{"location":"lvl1/objects/#object-identity","text":"Two objects are only compared equal if they are the exact same object. In this context 'sameness' does not mean the the contents of the two objects, but whether they point to the same thing in memory. Consider the following examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var player1 = { score: 0 lives: 3 health: 100 } var player2 = { score: 0 lives: 3 health: 100 } var player3 = player1; player1 is player2 # no player1 is player3 # yes Comparing two objects for equality by value requires inspection of individual properties. 1 2 3 4 5 6 7 8 9 10 11 def equalObj x, y if x is y # optimization in case two objects are identical yes else for key, val in x if val isnt y[key] return no yes equalObj player1, player2 # yes equalObj player1, player3 # yes Note The reason this kind of object comparison is not provided out of the box is that it is (a) expensive, and (b) objects can be arbitrarily nested, in which case it becomes even more complex and expensive.","title":"Object identity"},{"location":"lvl1/objects/#object-types-and-classes","text":"All objects have a type 'object' regardless of a class or constructor. To determine whether some object is an instance of a class, we use the isa operator. If we create an object using a Date constructor from the standard JavaScript API, we are able to tell it is a Date object. 1 2 3 4 5 var d = Date.new var notDate = {} d isa Date # yes notDate isa Date # no Note that all objects are ultimately of the class Object because any class or constructor inherits from this class. 1 d isa Object # yes Inheritance will be discussed in more detail in level 2, when we talk about classes .","title":"Object types and classes"},{"location":"lvl1/operators/","text":"Operators \u00b6 Operators are used as part of expressions to express operations on one or more values. Some operators will work on one type, while others may work on any type. Some operators operate on a single value (unary operators), while others operate on values on the either side (binary operators). In the 'usage' column, we will use a and b to mean values or expressions. In the 'Assignment operators' section, a is either a variable or a property on an object. If either a or b is written with a capital letter ( A and B ), then it is a class. Note We use the term 'nullable' to refer to values that could be either null or undefined . Cheats \u00b6 Most JavaScript operators work in Imba. Ternary operator is if cond then x else y . === can be written as x is y (also x isnt y for negation). Negation can be written as not x . instanceof can be written as x isa Ctor . Conditional assignment when not nullable using x ?= y . Conditional member access when not nullable using x?:key and x?.key . new operator is written as a static method Ctor.new . There are no yield and ** operators. List of operators \u00b6 Arithmetic operators \u00b6 op. usage description - -a negative a + +a plus a , or just a + a + b add a to b - a - b subtract b from a * a * b multiply a by b / a / b divide a by b % a % b remainder of division of a by b ++ a++ increment then evaluate ++ ++a evaluate then increment -- a-- decrement then evaluate -- --a evaluate then decrement Comparison operators \u00b6 op. usage description is a is b a is identical to b (are same) isnt a isnt b a is not identical to b (aren't same) == a == b a equals b (but not identical) != a != b a does not equal b === a === b same as a is b !== a !== b same as a isnt b > a > b a is greater than b >= a >= b a is greater than or equals b < a < b a is less than b <= a <= b a is less than or equals b Bitwise operators \u00b6 op. usage description ~ ~a bitwise not a & a & b bitwise a AND b | a | b bitwise a OR b ^ a ^ b bitwise a XOR b >> a >> b bitwise signed right shift a by b positions >>> a >>> b bitwise unsigned right shift a by b positions << a << b bitwise left shift a by b positions Logical operators \u00b6 op. usage description not not a logical not a ! !a same as not a and a and b logical a AND b && a && b same as a and b or a or b logical a OR b ( b evaluated when a is falsy) || a || b same as a or b Relational operators \u00b6 op. usage description in a in b whether value a exists in array b isa a isa B whether a is an instance of class B instanceof a instanceof B same as a isa b Assignment operators \u00b6 op. usage description = a = b assign value b to variable a ?= a ?= b assign value b to a if a is nullable += a += b add b to a and assign to a -= a -= b subtract b from a and assign to a *= a *= b multiply a by b and assign to a /= a /= b divide a by b and assign to a %= a %= b divide a by b and assign the remainder to a &= a &= b bitwise AND a and b and assign to a |= a |= b bitwise OR a and b and assign to a ^= b ^= b bitwise XOR a and b and assign to a >>= a >>= b bitwise sig. right shift a by b and assign to a >>>= a >>>= b bitwise uns. right shift a by b and assign to a <<= a <<= b bitwise left shift a by b and assign to a Comma operator \u00b6 op. usage description , a, b evaluate a then b , evaluate everything as b Grouping operator \u00b6 op. usage description (...) (a) evaluate a with priority Member access \u00b6 op. usage description [ ] a[b] computed member b of an object/array a : a:b member b of an object a ?: a?:b member b of an object a if a isn't nullable . a.b invoke method b of object a ?. a?.b invoke method b object a if a isn't nullable Other operators \u00b6 op. usage description .new A.new b create an instance of class A with argument b delete delete a:b delete property b of object a typeof typeof a the type of value a await await a suspend an async function until a resolves Ternary operator \u00b6 op. usage description if-then if a then b else c if a is truthy, then b otherwise c Operator precedence \u00b6 Not all operators have equal importance when an expression consists of multiple operators. The order in which operators are evaluated depends on whether an operator is left- or right-associative. Left-associative means that for a given operator X , a X b X c is treated as (a X b) X c : from left to right. Right-associative means that for a given operator X , an expression a X b X c will evaluate as a X (b X c) : from right to left. All binary Imba operators are left-associative. Some operators are also generally more important regardless of associativity. As in mathematics, multiplication and division are more important than addition and subtraction, for example. The following is a list of all the operators ordered by importance. The 'score' column is there to provide an indication of what operators have the same importance. score op. 20 (...) 19 all member access operators function calls in 18 postfix increment and decrement 17 .new 16 logical and bitwise NOT unary arithmetic operators unary logical operators unary bitwise operators typeof delete await 15 (left blank for future use) 14 * , / , % 13 + , - 12 bitwise shift operators 11 > , >= , < , <= isa , instanceof 10 is , == , === , isnt , !== 9 & 8 ^ 7 | 6 and , && 5 or , || 4 ternary operator ?: , ?. 3 all assignment operators 2 (left blank for future use) 1 ,","title":"Operators"},{"location":"lvl1/operators/#operators","text":"Operators are used as part of expressions to express operations on one or more values. Some operators will work on one type, while others may work on any type. Some operators operate on a single value (unary operators), while others operate on values on the either side (binary operators). In the 'usage' column, we will use a and b to mean values or expressions. In the 'Assignment operators' section, a is either a variable or a property on an object. If either a or b is written with a capital letter ( A and B ), then it is a class. Note We use the term 'nullable' to refer to values that could be either null or undefined .","title":"Operators"},{"location":"lvl1/operators/#cheats","text":"Most JavaScript operators work in Imba. Ternary operator is if cond then x else y . === can be written as x is y (also x isnt y for negation). Negation can be written as not x . instanceof can be written as x isa Ctor . Conditional assignment when not nullable using x ?= y . Conditional member access when not nullable using x?:key and x?.key . new operator is written as a static method Ctor.new . There are no yield and ** operators.","title":"Cheats"},{"location":"lvl1/operators/#list-of-operators","text":"","title":"List of operators"},{"location":"lvl1/operators/#arithmetic-operators","text":"op. usage description - -a negative a + +a plus a , or just a + a + b add a to b - a - b subtract b from a * a * b multiply a by b / a / b divide a by b % a % b remainder of division of a by b ++ a++ increment then evaluate ++ ++a evaluate then increment -- a-- decrement then evaluate -- --a evaluate then decrement","title":"Arithmetic operators"},{"location":"lvl1/operators/#comparison-operators","text":"op. usage description is a is b a is identical to b (are same) isnt a isnt b a is not identical to b (aren't same) == a == b a equals b (but not identical) != a != b a does not equal b === a === b same as a is b !== a !== b same as a isnt b > a > b a is greater than b >= a >= b a is greater than or equals b < a < b a is less than b <= a <= b a is less than or equals b","title":"Comparison operators"},{"location":"lvl1/operators/#bitwise-operators","text":"op. usage description ~ ~a bitwise not a & a & b bitwise a AND b | a | b bitwise a OR b ^ a ^ b bitwise a XOR b >> a >> b bitwise signed right shift a by b positions >>> a >>> b bitwise unsigned right shift a by b positions << a << b bitwise left shift a by b positions","title":"Bitwise operators"},{"location":"lvl1/operators/#logical-operators","text":"op. usage description not not a logical not a ! !a same as not a and a and b logical a AND b && a && b same as a and b or a or b logical a OR b ( b evaluated when a is falsy) || a || b same as a or b","title":"Logical operators"},{"location":"lvl1/operators/#relational-operators","text":"op. usage description in a in b whether value a exists in array b isa a isa B whether a is an instance of class B instanceof a instanceof B same as a isa b","title":"Relational operators"},{"location":"lvl1/operators/#assignment-operators","text":"op. usage description = a = b assign value b to variable a ?= a ?= b assign value b to a if a is nullable += a += b add b to a and assign to a -= a -= b subtract b from a and assign to a *= a *= b multiply a by b and assign to a /= a /= b divide a by b and assign to a %= a %= b divide a by b and assign the remainder to a &= a &= b bitwise AND a and b and assign to a |= a |= b bitwise OR a and b and assign to a ^= b ^= b bitwise XOR a and b and assign to a >>= a >>= b bitwise sig. right shift a by b and assign to a >>>= a >>>= b bitwise uns. right shift a by b and assign to a <<= a <<= b bitwise left shift a by b and assign to a","title":"Assignment operators"},{"location":"lvl1/operators/#comma-operator","text":"op. usage description , a, b evaluate a then b , evaluate everything as b","title":"Comma operator"},{"location":"lvl1/operators/#grouping-operator","text":"op. usage description (...) (a) evaluate a with priority","title":"Grouping operator"},{"location":"lvl1/operators/#member-access","text":"op. usage description [ ] a[b] computed member b of an object/array a : a:b member b of an object a ?: a?:b member b of an object a if a isn't nullable . a.b invoke method b of object a ?. a?.b invoke method b object a if a isn't nullable","title":"Member access"},{"location":"lvl1/operators/#other-operators","text":"op. usage description .new A.new b create an instance of class A with argument b delete delete a:b delete property b of object a typeof typeof a the type of value a await await a suspend an async function until a resolves","title":"Other operators"},{"location":"lvl1/operators/#ternary-operator","text":"op. usage description if-then if a then b else c if a is truthy, then b otherwise c","title":"Ternary operator"},{"location":"lvl1/operators/#operator-precedence","text":"Not all operators have equal importance when an expression consists of multiple operators. The order in which operators are evaluated depends on whether an operator is left- or right-associative. Left-associative means that for a given operator X , a X b X c is treated as (a X b) X c : from left to right. Right-associative means that for a given operator X , an expression a X b X c will evaluate as a X (b X c) : from right to left. All binary Imba operators are left-associative. Some operators are also generally more important regardless of associativity. As in mathematics, multiplication and division are more important than addition and subtraction, for example. The following is a list of all the operators ordered by importance. The 'score' column is there to provide an indication of what operators have the same importance. score op. 20 (...) 19 all member access operators function calls in 18 postfix increment and decrement 17 .new 16 logical and bitwise NOT unary arithmetic operators unary logical operators unary bitwise operators typeof delete await 15 (left blank for future use) 14 * , / , % 13 + , - 12 bitwise shift operators 11 > , >= , < , <= isa , instanceof 10 is , == , === , isnt , !== 9 & 8 ^ 7 | 6 and , && 5 or , || 4 ternary operator ?: , ?. 3 all assignment operators 2 (left blank for future use) 1 ,","title":"Operator precedence"},{"location":"lvl1/primitives/","text":"Primitive types \u00b6 All programming languages have some notion of types. In simple terms, types are the 'kind' of values. They determine what we can do with them. Types exist because different operations we perform on values do not always make sense for all values. For example we cannot divide a number 3 by a word 'chair'. That does not make any sense. Note In Imba, there is no direct relationship between types and classes. In Imba, values have one of the following types: number string boolean undefined null regular expression object array function For the purposes of this guide, we divide types into primitive and complex types. This section only covers the primitive types. Those are: number string boolean undefined null The rest of the types are covered in other sections. Note Because all types in Imba are inherited from JavaScript itself, a link to the Mozilla Developer Network documentation page on each type will be provided. It is recommended to read those pages as well. Cheats \u00b6 All types are the same as in JavaScript, only minor syntax differences. typeof operator works the same way as in JavaScript. Double-quoted string is also a template string, embed with \"{expr}\" . Single-quoted string cannot be used as templates. Multi-line strings supported via \"\"\" and ''' . Multi-line double-quoted strings are also template strings. Booleans can also be written as yes and no (idiomatic). Indentation of multi-line string is honored (aligned to first line). typeof null is 'object' like in JavaScript. Sorry. Testing for types \u00b6 To determine the type of some value, we use the typeof operator. Writing typeof followed by an expression evaluates to a string that containing the name of the type. 1 typeof 1 # 'number' For each type discussed in this section, we will also include the expected result of using typeof with the value. Also see Alternative type detection for a more advanced and generally not extremely useful approach. Number \u00b6 typeof: number MDN: Number All numeric values in Imba are of type 'number'. Unlike many other languages, Imba does not make any distinction between floating point and integer numbers, and has no representation of rational, irrational, decimal, and other types of numbers. Here are some examples of numbers: 1 2 3 4 5 1 0 1242 12.4 53.6666666661 Technically, JavaScript number type is a double-precision floating point number, and has a range of -(2^53-1) to (2^53 - 1). The maximum value for numbers on a given platform (browser, NodeJS) can be obtained using Number:MAX_VALUE constant. Normally this should be 1.7976931348623157e+308. The largest integer that can be safely represented in JavaScript can be obtained using Number:MAX_SAFE_INTEGER . Normally, this should be 9007199254740991. Useful methods and properties: .toFixed .toLocaleString Math object NaN (Not a Number) \u00b6 typeof: number MDN: NaN NaN is not a type on its own. It is rather a special value of the 'number' type. It represents a value that is a nun-number, usually a result of an invalid computation. NaN was present in JavaScript since the very beginnings in order to avoid critical failure of programs in face of invalid mathematical operations such as division by zero. Result of any such operation is always NaN . The NaN is never equal to any value, including NaN itself. It is therefore not possible to test whether a value is a NaN using equality test. 1 2 9 / 0 === NaN # this will be false NaN === NaN # this is also false We test for NaN using either the global isNaN function or Number.isNaN function. Main difference is that the global function tests if a value is anything but a number ( NaN , string, Boolean, etc.) whereas Number.isNaN tests only if a value is NaN . 1 2 3 4 5 6 7 8 isNaN 2 # no isNaN 'number' # yes isNaN 9 / 0 # yes isNaN NaN # yes Number.isNaN 2 # no Number.isNaN 'number' # no Number.isNaN 9 / 0 # yes Number.isNan NaN # yes String \u00b6 typeof: string MDN: String Character sequences (characters, words, text, etc.) are of type 'string'. A string is represented as either single-quoted or double-quoted string of characters: 1 2 'single-quoted' \"double-quoted\" There is no separate type for single characters. Single characters are represented as strings with a single character. 1 2 'string' 'c' Imba strings are fully Unicode. There are no different types of Unicode and non-Unicode strings. 1 '\u65e5\u672c\u8a9e' Empty strings are represented with quotes that have no characters in them. 1 2 '' \"\" Double-quoted strings are, for the most part, exactly the same as single-quoted ones, except that they also support expression interpolation. 1 2 3 4 5 \"string\" \"embed {1 + 2}\" var someNumber = 12 \"embed {someNumber}\" Keep in mind that we are embedding expressions, so any valid expression can go into the curly braces, including control structures. Some characters within strings must be escaped. This includes characters like tab, newline, carriage return, and quotes. For instance: 1 var stringWithTab = '\\tindented' The sequence of backslash \\ followed by one or more character is called an 'escape sequence' and represents these special characters. Here is a list of common escape sequences: \\' - single quote (used for single quotes inside single-quoted strings) \\\" - double quote (used for double quotes inside double-quoted strings) \\n - newline \\t - tab \\\\ - backspace itself A full list of recognized escape sequences can be found in an appendix . Imba also has a syntax for multi-line strings. These are strings where whitespace characters do not have to be explicitly escaped. Multi-line strings are quoted using sets of three single- or double-quotes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 var longerText = \"\"\" A voluptates enim omnis. Eius exercitationem ad qui nemo atque aut asperiores. Modi perferendis qui dolor doloribus aut quia. Culpa est harum beatae ipsam aut accusamus dolorum. Quo qui quia fugit incidunt consequuntur. Voluptas omnis nihil nam corporis. Earum ut eum excepturi at. \"\"\" var longerSingle = ''' A voluptates enim omnis. Eius exercitationem ad qui nemo atque aut asperiores. Modi perferendis qui dolor doloribus aut quia. ''' Note that in both cases, indentation is ignored. In the first example, the second paragraph of the text is indented only 3 spaces compared to the first one. As with normal single- and double-quoted strings, embedding expressions only works with the double-quoted variant. Useful methods and properties: .endsWith .includes .lastIndexOf .padEnd .padStart .repeat .replace .search .split .startsWith .substring .toLowerCase .toUpperCase .trim Boolean \u00b6 typeof: boolean MDN: Boolean The 'boolean' type has only two values, True and False. As their name suggests, they represent truth values, and are commonly used in logic operations. In Imba, boolean values have two names for each of the two values. The truth value for True can be written as either true or yes , whereas the False can be written as either false or no . Both forms are exactly the same and the choice is a matter of preference. 1 2 3 4 5 true yes false no The boolean values can be used in numeric operations as 1 (for true ) and 0 (for false ). It is not recommended to do this too often as it makes the code harder to analyze most of the time. 1 2 ['Nope', 'Right on!'][yes] # 'Right on!' Undefined \u00b6 typeof: boolean MDN: undefined There is only one value of the type 'undefined'. Undefined represents a an absence of value. It has the same meaning and semantics as the JavaScript counterparts. Undefined value is represented by the undefined keyword. The value appears frequently to represent different things that are missing. For example when a missing property on an object is accessed, undefined is returned. When an argument is not passed for a given function parameter, it is undefined , and so on. Null \u00b6 typeof: object MDN: null The null value may seem similar to undefined but it is a value that represents 'no value'. Null value is represented using the null keyword. To differentiate between undefined and null conceptually, you could think of undefined as being unintentional, and null as intentional absence of value. Most of the time, the difference technically does not matter, but it is common for methods that can foreseeably return no useful value to return null rather than undefined (e.g., documnent.getElementById when an element with a specified id does not exist). The null value is of type 'object'. This is not a typo, and it's by design, inherited as is from JavaScript. 1 2 var x = null x === null # yes Another important property of null value is that it compares equal to undefined when non-strict equality operator is used: 1 2 null === undefined # no null == undefined # yes Truthy and falsy values \u00b6 Even though Booleans are clear indication of truth, in general comparisons in Imba programs, they are not the only values that can be used as truth values. Imba values all fall under either 'truthy' or 'falsy' buckets. Truthy values are treated the same as true , while falsy values are treated as false . The following values are falsy: undefined null 0 '' NaN All other values, primitive or otherwise, are truthy. To convert any value to real boolean based on their 'truthyness', we can simply use double-negation. 1 2 3 4 5 var aFalsy = 0 var aTruthy = \"I'm so true!\" not not aFalsy # no not not aTruthy # yes Since the double negation is a bit long written with not not , we can also use the short negation operator ! twice. 1 2 !!aFalsy # no !!aTruthy # yes","title":"Primitive types"},{"location":"lvl1/primitives/#primitive-types","text":"All programming languages have some notion of types. In simple terms, types are the 'kind' of values. They determine what we can do with them. Types exist because different operations we perform on values do not always make sense for all values. For example we cannot divide a number 3 by a word 'chair'. That does not make any sense. Note In Imba, there is no direct relationship between types and classes. In Imba, values have one of the following types: number string boolean undefined null regular expression object array function For the purposes of this guide, we divide types into primitive and complex types. This section only covers the primitive types. Those are: number string boolean undefined null The rest of the types are covered in other sections. Note Because all types in Imba are inherited from JavaScript itself, a link to the Mozilla Developer Network documentation page on each type will be provided. It is recommended to read those pages as well.","title":"Primitive types"},{"location":"lvl1/primitives/#cheats","text":"All types are the same as in JavaScript, only minor syntax differences. typeof operator works the same way as in JavaScript. Double-quoted string is also a template string, embed with \"{expr}\" . Single-quoted string cannot be used as templates. Multi-line strings supported via \"\"\" and ''' . Multi-line double-quoted strings are also template strings. Booleans can also be written as yes and no (idiomatic). Indentation of multi-line string is honored (aligned to first line). typeof null is 'object' like in JavaScript. Sorry.","title":"Cheats"},{"location":"lvl1/primitives/#testing-for-types","text":"To determine the type of some value, we use the typeof operator. Writing typeof followed by an expression evaluates to a string that containing the name of the type. 1 typeof 1 # 'number' For each type discussed in this section, we will also include the expected result of using typeof with the value. Also see Alternative type detection for a more advanced and generally not extremely useful approach.","title":"Testing for types"},{"location":"lvl1/primitives/#number","text":"typeof: number MDN: Number All numeric values in Imba are of type 'number'. Unlike many other languages, Imba does not make any distinction between floating point and integer numbers, and has no representation of rational, irrational, decimal, and other types of numbers. Here are some examples of numbers: 1 2 3 4 5 1 0 1242 12.4 53.6666666661 Technically, JavaScript number type is a double-precision floating point number, and has a range of -(2^53-1) to (2^53 - 1). The maximum value for numbers on a given platform (browser, NodeJS) can be obtained using Number:MAX_VALUE constant. Normally this should be 1.7976931348623157e+308. The largest integer that can be safely represented in JavaScript can be obtained using Number:MAX_SAFE_INTEGER . Normally, this should be 9007199254740991. Useful methods and properties: .toFixed .toLocaleString Math object","title":"Number"},{"location":"lvl1/primitives/#nan-not-a-number","text":"typeof: number MDN: NaN NaN is not a type on its own. It is rather a special value of the 'number' type. It represents a value that is a nun-number, usually a result of an invalid computation. NaN was present in JavaScript since the very beginnings in order to avoid critical failure of programs in face of invalid mathematical operations such as division by zero. Result of any such operation is always NaN . The NaN is never equal to any value, including NaN itself. It is therefore not possible to test whether a value is a NaN using equality test. 1 2 9 / 0 === NaN # this will be false NaN === NaN # this is also false We test for NaN using either the global isNaN function or Number.isNaN function. Main difference is that the global function tests if a value is anything but a number ( NaN , string, Boolean, etc.) whereas Number.isNaN tests only if a value is NaN . 1 2 3 4 5 6 7 8 isNaN 2 # no isNaN 'number' # yes isNaN 9 / 0 # yes isNaN NaN # yes Number.isNaN 2 # no Number.isNaN 'number' # no Number.isNaN 9 / 0 # yes Number.isNan NaN # yes","title":"NaN (Not a Number)"},{"location":"lvl1/primitives/#string","text":"typeof: string MDN: String Character sequences (characters, words, text, etc.) are of type 'string'. A string is represented as either single-quoted or double-quoted string of characters: 1 2 'single-quoted' \"double-quoted\" There is no separate type for single characters. Single characters are represented as strings with a single character. 1 2 'string' 'c' Imba strings are fully Unicode. There are no different types of Unicode and non-Unicode strings. 1 '\u65e5\u672c\u8a9e' Empty strings are represented with quotes that have no characters in them. 1 2 '' \"\" Double-quoted strings are, for the most part, exactly the same as single-quoted ones, except that they also support expression interpolation. 1 2 3 4 5 \"string\" \"embed {1 + 2}\" var someNumber = 12 \"embed {someNumber}\" Keep in mind that we are embedding expressions, so any valid expression can go into the curly braces, including control structures. Some characters within strings must be escaped. This includes characters like tab, newline, carriage return, and quotes. For instance: 1 var stringWithTab = '\\tindented' The sequence of backslash \\ followed by one or more character is called an 'escape sequence' and represents these special characters. Here is a list of common escape sequences: \\' - single quote (used for single quotes inside single-quoted strings) \\\" - double quote (used for double quotes inside double-quoted strings) \\n - newline \\t - tab \\\\ - backspace itself A full list of recognized escape sequences can be found in an appendix . Imba also has a syntax for multi-line strings. These are strings where whitespace characters do not have to be explicitly escaped. Multi-line strings are quoted using sets of three single- or double-quotes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 var longerText = \"\"\" A voluptates enim omnis. Eius exercitationem ad qui nemo atque aut asperiores. Modi perferendis qui dolor doloribus aut quia. Culpa est harum beatae ipsam aut accusamus dolorum. Quo qui quia fugit incidunt consequuntur. Voluptas omnis nihil nam corporis. Earum ut eum excepturi at. \"\"\" var longerSingle = ''' A voluptates enim omnis. Eius exercitationem ad qui nemo atque aut asperiores. Modi perferendis qui dolor doloribus aut quia. ''' Note that in both cases, indentation is ignored. In the first example, the second paragraph of the text is indented only 3 spaces compared to the first one. As with normal single- and double-quoted strings, embedding expressions only works with the double-quoted variant. Useful methods and properties: .endsWith .includes .lastIndexOf .padEnd .padStart .repeat .replace .search .split .startsWith .substring .toLowerCase .toUpperCase .trim","title":"String"},{"location":"lvl1/primitives/#boolean","text":"typeof: boolean MDN: Boolean The 'boolean' type has only two values, True and False. As their name suggests, they represent truth values, and are commonly used in logic operations. In Imba, boolean values have two names for each of the two values. The truth value for True can be written as either true or yes , whereas the False can be written as either false or no . Both forms are exactly the same and the choice is a matter of preference. 1 2 3 4 5 true yes false no The boolean values can be used in numeric operations as 1 (for true ) and 0 (for false ). It is not recommended to do this too often as it makes the code harder to analyze most of the time. 1 2 ['Nope', 'Right on!'][yes] # 'Right on!'","title":"Boolean"},{"location":"lvl1/primitives/#undefined","text":"typeof: boolean MDN: undefined There is only one value of the type 'undefined'. Undefined represents a an absence of value. It has the same meaning and semantics as the JavaScript counterparts. Undefined value is represented by the undefined keyword. The value appears frequently to represent different things that are missing. For example when a missing property on an object is accessed, undefined is returned. When an argument is not passed for a given function parameter, it is undefined , and so on.","title":"Undefined"},{"location":"lvl1/primitives/#null","text":"typeof: object MDN: null The null value may seem similar to undefined but it is a value that represents 'no value'. Null value is represented using the null keyword. To differentiate between undefined and null conceptually, you could think of undefined as being unintentional, and null as intentional absence of value. Most of the time, the difference technically does not matter, but it is common for methods that can foreseeably return no useful value to return null rather than undefined (e.g., documnent.getElementById when an element with a specified id does not exist). The null value is of type 'object'. This is not a typo, and it's by design, inherited as is from JavaScript. 1 2 var x = null x === null # yes Another important property of null value is that it compares equal to undefined when non-strict equality operator is used: 1 2 null === undefined # no null == undefined # yes","title":"Null"},{"location":"lvl1/primitives/#truthy-and-falsy-values","text":"Even though Booleans are clear indication of truth, in general comparisons in Imba programs, they are not the only values that can be used as truth values. Imba values all fall under either 'truthy' or 'falsy' buckets. Truthy values are treated the same as true , while falsy values are treated as false . The following values are falsy: undefined null 0 '' NaN All other values, primitive or otherwise, are truthy. To convert any value to real boolean based on their 'truthyness', we can simply use double-negation. 1 2 3 4 5 var aFalsy = 0 var aTruthy = \"I'm so true!\" not not aFalsy # no not not aTruthy # yes Since the double negation is a bit long written with not not , we can also use the short negation operator ! twice. 1 2 !!aFalsy # no !!aTruthy # yes","title":"Truthy and falsy values"},{"location":"lvl1/regexps/","text":"Regular expressions \u00b6 Regular expression is a language that represents patterns in strings. Different programming languages have different flavors of this notation. Imba uses the JavaScript flavor. Regular expressions are used to test for, search for or extract character patterns in strings. Cheats \u00b6 The regular expression syntax and flags are the same as in JavaScript. Multi-line regular expressions are supported with /// . Unescaped whitespace in multi-line regular expressions are ignored. Writing regular expressions \u00b6 Single line regular expressions are written in the /pattern/modifiers form, and the multi-line regular expressions are written with triple-slashes. In multi-line regular expressions, any unescaped whitespace is collapsed, which is not the case with single-line expressions. This is an example of a single-line regular expression: 1 /reg exp/ This is an example of a multi-line regular expression: 1 2 3 4 5 6 /// (can use multi-line regexp # Can add comments inside the regular expressions. | that ignores whitespace )? /// The second example is identical to the following: 1 /(canusemulti-lineregexp|thatignoreswhitespace)?/ Regular expressions can have flags. The flags are single characters that are written directly after the closing slash / . These flags change the way regular expressions operate. 1 /reg exp/gi The example regular expression has g and i flags. The g flag tells the regular expression to apply 'globally' (match all occurrences, not just the first one), and i flag tells it to 'ignore' the differences between upper- and lower-case letters. Regular expressions can also be created from strings using the RegExp constructor. 1 RegExp.new '\\\\w+', 'gi' Although the regular expression literal syntax is normally preferred, the constructor can be used to create regular expressions dynamically by using template strings: 1 2 var name = 'John' RegExp.new \"[a-z]+_{name}\\\\.txt\", 'i' Warning When constructing regular expressions from strings with embedded variables, you should be careful to escape any backslashes in the variable. Failure to do so may allow the users of your program to modify the meaning of your regular expression by including backslashes in the input. Regular expression syntax \u00b6 Regular expressions in Imba use the same notation as the JavaScript regular expressions, so we will not provide a full reference on the syntax. See the MDN article on regular expressions for more details. Useful methods and properties \u00b6 :flags :global :ignoreCase :lastIndex :multiline :source :sticky :unicode .exec .test String methods that accept regular expressions \u00b6 Some string methods accept regular expressions. These are: .replace .split .match .replace","title":"Regular expressions"},{"location":"lvl1/regexps/#regular-expressions","text":"Regular expression is a language that represents patterns in strings. Different programming languages have different flavors of this notation. Imba uses the JavaScript flavor. Regular expressions are used to test for, search for or extract character patterns in strings.","title":"Regular expressions"},{"location":"lvl1/regexps/#cheats","text":"The regular expression syntax and flags are the same as in JavaScript. Multi-line regular expressions are supported with /// . Unescaped whitespace in multi-line regular expressions are ignored.","title":"Cheats"},{"location":"lvl1/regexps/#writing-regular-expressions","text":"Single line regular expressions are written in the /pattern/modifiers form, and the multi-line regular expressions are written with triple-slashes. In multi-line regular expressions, any unescaped whitespace is collapsed, which is not the case with single-line expressions. This is an example of a single-line regular expression: 1 /reg exp/ This is an example of a multi-line regular expression: 1 2 3 4 5 6 /// (can use multi-line regexp # Can add comments inside the regular expressions. | that ignores whitespace )? /// The second example is identical to the following: 1 /(canusemulti-lineregexp|thatignoreswhitespace)?/ Regular expressions can have flags. The flags are single characters that are written directly after the closing slash / . These flags change the way regular expressions operate. 1 /reg exp/gi The example regular expression has g and i flags. The g flag tells the regular expression to apply 'globally' (match all occurrences, not just the first one), and i flag tells it to 'ignore' the differences between upper- and lower-case letters. Regular expressions can also be created from strings using the RegExp constructor. 1 RegExp.new '\\\\w+', 'gi' Although the regular expression literal syntax is normally preferred, the constructor can be used to create regular expressions dynamically by using template strings: 1 2 var name = 'John' RegExp.new \"[a-z]+_{name}\\\\.txt\", 'i' Warning When constructing regular expressions from strings with embedded variables, you should be careful to escape any backslashes in the variable. Failure to do so may allow the users of your program to modify the meaning of your regular expression by including backslashes in the input.","title":"Writing regular expressions"},{"location":"lvl1/regexps/#regular-expression-syntax","text":"Regular expressions in Imba use the same notation as the JavaScript regular expressions, so we will not provide a full reference on the syntax. See the MDN article on regular expressions for more details.","title":"Regular expression syntax"},{"location":"lvl1/regexps/#useful-methods-and-properties","text":":flags :global :ignoreCase :lastIndex :multiline :source :sticky :unicode .exec .test","title":"Useful methods and properties"},{"location":"lvl1/regexps/#string-methods-that-accept-regular-expressions","text":"Some string methods accept regular expressions. These are: .replace .split .match .replace","title":"String methods that accept regular expressions"},{"location":"lvl1/statements/","text":"Statements and expressions \u00b6 Statements and expressions are how we organize our code and express various concepts. Knowing the difference between statements and expressions will be very important for programming effectively with Imba. Warning Some of the things you normally use as a statement in JavaScript are expressions in Imba. Cheats \u00b6 One statement per line. Multiple statements per line when separated by ; . Blocks like if , try , when , until , for are expressions. Definitions \u00b6 Statements are instructions for the computer to perform some action. Expressions are various representations of values. They can be a single value (e.g., 1 ) or very complex ( if x > 1 then createPrevious else null ), but it is always possible to treat them as a single value. Statements in imba \u00b6 Each line in an Imba program is a statement. A line can sometimes contain multiple statements separated by a semi-colon ; . This is not common, and is generally not recommended. Each statement comprises of one or more expressions, or statements. When a statement contains statements, we say that it is a compound statement. For example: 1 2 3 var x = 1 # `var` statement, `1` is an expression x + 1 # single expression extern isNaN # single statement `extern`, `isNaN` is an expression Blocks (compound statements) \u00b6 Some statements mark the start of a block. Subsequent lines, until the end of the block are all part of a compound statement. Warning JavaScript uses block delimiters (curly braces), while Imba uses significant whitespace. Blocks start with an opening statement, and then one or more statements that are indented by +1 level. Blocks end when a line is encountered that is indented at the same level as the opening statement. 1 2 3 4 def add x, y # `def` statement marks the start of a block x + y # this single expression statement is part of the block var n = 1 # this `var` statement is not part of the block The following statements create blocks: def var def if try when until for tag class Compound blocks \u00b6 Some blocks may have multiple indented regions which are all part of the same block. In case of the if conditional statement, else continues the block created by the if statement. 1 2 3 4 5 6 if x > 1 # `if` statement, `x > 1` expression x - 1 # single expression else if x === 1 # `else if` statement, `x === 1` expression x # single expression else # `else` statement 0 # single expression The following blocks can be compound: if - else try - catch Block expressions \u00b6 In many languages, blocks like if do not have a meaning on their own. The entire block, when executed, provides a meaning. In contrast, in Imba, if , while , until , and for blocks have a meaning on their own. They are treated as expressions that can be assigned and passed as arguments. This will be covered in more detail in the section on control structures . Wrapping expressions in parentheses \u00b6 Expressions can be wrapped in parentheses. This does not change the value of the expression, but it allows us to more clearly specify the order in which we want the expressions to evaluate. This is exactly the same as in maths. For instance: 1 2 12 - 3 * 4 # 0 (12 - 3) * 4 # 36","title":"Statements and expressions"},{"location":"lvl1/statements/#statements-and-expressions","text":"Statements and expressions are how we organize our code and express various concepts. Knowing the difference between statements and expressions will be very important for programming effectively with Imba. Warning Some of the things you normally use as a statement in JavaScript are expressions in Imba.","title":"Statements and expressions"},{"location":"lvl1/statements/#cheats","text":"One statement per line. Multiple statements per line when separated by ; . Blocks like if , try , when , until , for are expressions.","title":"Cheats"},{"location":"lvl1/statements/#definitions","text":"Statements are instructions for the computer to perform some action. Expressions are various representations of values. They can be a single value (e.g., 1 ) or very complex ( if x > 1 then createPrevious else null ), but it is always possible to treat them as a single value.","title":"Definitions"},{"location":"lvl1/statements/#statements-in-imba","text":"Each line in an Imba program is a statement. A line can sometimes contain multiple statements separated by a semi-colon ; . This is not common, and is generally not recommended. Each statement comprises of one or more expressions, or statements. When a statement contains statements, we say that it is a compound statement. For example: 1 2 3 var x = 1 # `var` statement, `1` is an expression x + 1 # single expression extern isNaN # single statement `extern`, `isNaN` is an expression","title":"Statements in imba"},{"location":"lvl1/statements/#blocks-compound-statements","text":"Some statements mark the start of a block. Subsequent lines, until the end of the block are all part of a compound statement. Warning JavaScript uses block delimiters (curly braces), while Imba uses significant whitespace. Blocks start with an opening statement, and then one or more statements that are indented by +1 level. Blocks end when a line is encountered that is indented at the same level as the opening statement. 1 2 3 4 def add x, y # `def` statement marks the start of a block x + y # this single expression statement is part of the block var n = 1 # this `var` statement is not part of the block The following statements create blocks: def var def if try when until for tag class","title":"Blocks (compound statements)"},{"location":"lvl1/statements/#compound-blocks","text":"Some blocks may have multiple indented regions which are all part of the same block. In case of the if conditional statement, else continues the block created by the if statement. 1 2 3 4 5 6 if x > 1 # `if` statement, `x > 1` expression x - 1 # single expression else if x === 1 # `else if` statement, `x === 1` expression x # single expression else # `else` statement 0 # single expression The following blocks can be compound: if - else try - catch","title":"Compound blocks"},{"location":"lvl1/statements/#block-expressions","text":"In many languages, blocks like if do not have a meaning on their own. The entire block, when executed, provides a meaning. In contrast, in Imba, if , while , until , and for blocks have a meaning on their own. They are treated as expressions that can be assigned and passed as arguments. This will be covered in more detail in the section on control structures .","title":"Block expressions"},{"location":"lvl1/statements/#wrapping-expressions-in-parentheses","text":"Expressions can be wrapped in parentheses. This does not change the value of the expression, but it allows us to more clearly specify the order in which we want the expressions to evaluate. This is exactly the same as in maths. For instance: 1 2 12 - 3 * 4 # 0 (12 - 3) * 4 # 36","title":"Wrapping expressions in parentheses"},{"location":"lvl1/vars/","text":"Variables and variable scope \u00b6 Variables are labels for values. When a variable appears in the code, it can be usually be substituted for a value. The value variables are substituted for are assigned to them at some point the program's execution (if ever). Variables (as their name suggest) are used as placeholders for values that could change during execution. Cheats \u00b6 Variables are declared with var , const , and let . Variable scope is exactly the same as in JavaScript. const and let are not transpiled (they are literal let / const ). const is not checked for reassignment at compile time. Don't (ab)use hoisting. Undeclared names are treated as method calls. Declaring and assigning values \u00b6 In Imba, variables are first declared, and then values can be assigned to them one or more times. 1 2 3 4 5 var x # we have declared a variable `x` x = 1 # we have assigned a value `1` to `x` x # we have referenced `x` and we got `1` x = 2 # reassigned `x` with a value `2` x # referenced `x` again, this time we got `2` We can declare and assign in a single statement like this: 1 var x = 1 Allowed variable names \u00b6 Variable names can contain any letter, numbers, or an underscore. The names cannot start the names with numbers, though. 1 2 3 4 5 6 var foo # OK var foo1 # OK var FOO # OK var foo_bar # OK var _foo # OK var 1foo # ERROR! Variable visibility (scope) \u00b6 Variables are only visible within, methods and do blocks inside which they are declared. Variables declared outside any method and do block are visible to the entire module. Variables are visible from any line below their declaration, including any methods, classes, tags and blocks that come after it, but this visibility does not extend past the end of the body of the method or do block, or outside the module. 1 2 3 4 5 6 7 8 9 10 var x = 12 # `x` is visible from all lines below this one def foo y # `y` is visible only inside the `foo` method var z # `z` is visible only inside the `foo` method z = do |n| # `n` is visible only inside the do block var f = 12 # `f` is visible only inside the do block f + y / n z 2 # This code is not supposed to make sense, don't worry. :-) Warning Because Imba code compiles to JavaScript, variables are subject to hoisting. However, because of the way Imba compiler treats variable references, you should not rely on hoisting, and instead always declare variables above the point where they are used.","title":"Variables and variable scope"},{"location":"lvl1/vars/#variables-and-variable-scope","text":"Variables are labels for values. When a variable appears in the code, it can be usually be substituted for a value. The value variables are substituted for are assigned to them at some point the program's execution (if ever). Variables (as their name suggest) are used as placeholders for values that could change during execution.","title":"Variables and variable scope"},{"location":"lvl1/vars/#cheats","text":"Variables are declared with var , const , and let . Variable scope is exactly the same as in JavaScript. const and let are not transpiled (they are literal let / const ). const is not checked for reassignment at compile time. Don't (ab)use hoisting. Undeclared names are treated as method calls.","title":"Cheats"},{"location":"lvl1/vars/#declaring-and-assigning-values","text":"In Imba, variables are first declared, and then values can be assigned to them one or more times. 1 2 3 4 5 var x # we have declared a variable `x` x = 1 # we have assigned a value `1` to `x` x # we have referenced `x` and we got `1` x = 2 # reassigned `x` with a value `2` x # referenced `x` again, this time we got `2` We can declare and assign in a single statement like this: 1 var x = 1","title":"Declaring and assigning values"},{"location":"lvl1/vars/#allowed-variable-names","text":"Variable names can contain any letter, numbers, or an underscore. The names cannot start the names with numbers, though. 1 2 3 4 5 6 var foo # OK var foo1 # OK var FOO # OK var foo_bar # OK var _foo # OK var 1foo # ERROR!","title":"Allowed variable names"},{"location":"lvl1/vars/#variable-visibility-scope","text":"Variables are only visible within, methods and do blocks inside which they are declared. Variables declared outside any method and do block are visible to the entire module. Variables are visible from any line below their declaration, including any methods, classes, tags and blocks that come after it, but this visibility does not extend past the end of the body of the method or do block, or outside the module. 1 2 3 4 5 6 7 8 9 10 var x = 12 # `x` is visible from all lines below this one def foo y # `y` is visible only inside the `foo` method var z # `z` is visible only inside the `foo` method z = do |n| # `n` is visible only inside the do block var f = 12 # `f` is visible only inside the do block f + y / n z 2 # This code is not supposed to make sense, don't worry. :-) Warning Because Imba code compiles to JavaScript, variables are subject to hoisting. However, because of the way Imba compiler treats variable references, you should not rely on hoisting, and instead always declare variables above the point where they are used.","title":"Variable visibility (scope)"},{"location":"lvl2/","text":"Advanced concepts \u00b6 This level builds on the previous one by introducing advanced concepts that most non-trivial Imba applications will have. It's primary goal is to introduce language features, so it will not try to go too deep into advanced programming topics like object-oriented programming and design patterns. We will, however, touch on those topics as appropriate. After clearing this level, you will be able to write complete Imba applications.","title":"Advanced concepts"},{"location":"lvl2/#advanced-concepts","text":"This level builds on the previous one by introducing advanced concepts that most non-trivial Imba applications will have. It's primary goal is to introduce language features, so it will not try to go too deep into advanced programming topics like object-oriented programming and design patterns. We will, however, touch on those topics as appropriate. After clearing this level, you will be able to write complete Imba applications.","title":"Advanced concepts"},{"location":"lvl2/async/","text":"","title":"Async"},{"location":"lvl2/classes/","text":"","title":"Classes"},{"location":"lvl2/global/","text":"","title":"Global"},{"location":"lvl2/listcomps/","text":"","title":"Listcomps"},{"location":"lvl2/modules/","text":"","title":"Modules"},{"location":"lvl2/tags/","text":"","title":"Tags"}]}